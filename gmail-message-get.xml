<?xml version="1.0" encoding="UTF-8"?><service-task-definition>
<label>Gmail: Get Email Message</label>
<label locale="ja">Gmail: メール取得</label>
<!--
<last-modified>2020-11-13</last-modified>
-->
<license>(C) Questetra, Inc. (MIT License)</license>
<engine-type>2</engine-type>
<summary>Get an email message in Gmail.</summary>
<summary locale="ja">Gmail のメールを取得します。</summary>
<configs>
  <config name="conf_auth" required="true" form-type="OAUTH2">
    <label>C1: Authorization Setting to connect Gmail</label>
    <label locale="ja">C1: Gmail に接続するための認証設定</label>
  </config>
  <config name="conf_messageId" required="true" form-type="SELECT" select-data-type="STRING_TEXTFIELD">
    <label>C2: Message ID</label>
    <label locale="ja">C2: メール ID</label>
  </config>
  <config name="conf_fromAddress" required="false" form-type="SELECT" select-data-type="STRING_TEXTFIELD">
    <label>C3: String type data item that will save From Address</label>
    <label locale="ja">C3: From メールアドレスを保存する文字型データ項目</label>
  </config>
  <config name="conf_fromName" required="false" form-type="SELECT" select-data-type="STRING_TEXTFIELD">
    <label>C4: String type data item that will save From Name</label>
    <label locale="ja">C4: From 表示名を保存する文字型データ項目</label>
  </config>
  <config name="conf_recipientAddresses" required="false" form-type="SELECT" select-data-type="STRING_TEXTAREA">
    <label>C5: String type data item that will save To/Cc/Bcc Addresses</label>
    <label locale="ja">C5: To/Cc/Bcc メールアドレス一覧を保存する文字型データ項目</label>
  </config>
  <config name="conf_recipientNames" required="false" form-type="SELECT" select-data-type="STRING_TEXTAREA">
    <label>C6: String type data item that will save To/Cc/Bcc Names</label>
    <label locale="ja">C6: To/Cc/Bcc 表示名一覧を保存する文字型データ項目</label>
  </config>
  <config name="conf_sentDatetime" required="false" form-type="SELECT" select-data-type="DATETIME">
    <label>C7: Datetime type data item that will save Sent Date and Time</label>
    <label locale="ja">C7: 送信日時を保存する日時型データ項目</label>
  </config>
  <config name="conf_subject" required="false" form-type="SELECT" select-data-type="STRING_TEXTFIELD">
    <label>C8: String type data item that will save Subject</label>
    <label locale="ja">C8: 件名を保存する文字型データ項目</label>
  </config>
  <config name="conf_body" required="false" form-type="SELECT" select-data-type="STRING_TEXTAREA">
    <label>C9: String type data item that will save Body</label>
    <label locale="ja">C9: 本文を保存する文字型データ項目</label>
  </config>
  <config name="conf_attachments" required="false" form-type="SELECT" select-data-type="FILE">
    <label>C10: File type data item that will save Attachments</label>
    <label locale="ja">C10: 添付ファイルを保存するファイル型データ項目</label>
  </config>
</configs>
<help-page-url>https://support.questetra.com/addons/gmail-message-get/</help-page-url>
<help-page-url locale="ja">https://support.questetra.com/ja/addons/gmail-message-get/</help-page-url>

<script><![CDATA[

// OAuth2 config sample at [OAuth 2.0 Setting]
// - Authorization Endpoint URL: https://accounts.google.com/o/oauth2/auth?access_type=offline&approval_prompt=force
// - Token Endpoint URL: https://oauth2.googleapis.com/token
// - Scope: https://www.googleapis.com/auth/gmail.readonly
// - Consumer Key: (Get by Google Developer Console)
// - Consumer Secret: (Get by Google Developer Console)

main();
function main(){
  //// == 工程コンフィグ・ワークフローデータの参照 / Config & Data Retrieving ==
  const auth = configs.get("conf_auth");
  const messageId = retrieveMessageId();

  const fromAddressDef = configs.getObject("conf_fromAddress");
  const fromNameDef = configs.getObject("conf_fromName");
  const recipientAddressesDef = configs.getObject("conf_recipientAddresses");
  const recipientNamesDef = configs.getObject("conf_recipientNames");
  const sentDatetimeDef = configs.getObject("conf_sentDatetime");
  const subjectDef = configs.getObject("conf_subject");
  const bodyDef = configs.getObject("conf_body");
  const attachmentsDef = configs.getObject("conf_attachments");

  const apiToken = httpClient.getOAuth2Token( auth );
  let files = engine.findData( attachmentsDef );
  if (files === null) {
    files = new java.util.ArrayList();
  }

  //// == 演算 / Calculating ==
  const apiUri = determineApiUri( messageId );
  const message = {
    "from": "",
    "recipients": [],
    "datetime": "",
    "subject": "",
    "body": "",
    "attachments": []
  };
  getMessage( apiUri, apiToken, message );
  engine.log( JSON.stringify( message ) ); // 確認用

  getAttachments( apiUri, apiToken, message.attachments );
  convertAndAddAttachments( message.attachments, files );

  //// == ワークフローデータへの代入 / Data Updating ==
  engine.setData( fromAddressDef, message.from ); // 現状は表示名もここに含まれたまま
  engine.setData( recipientAddressesDef, message.recipients.join('\n') ); // 現状は表示名もここに含まれたまま
  engine.setData( sentDatetimeDef, new java.sql.Timestamp(Date.parse(message.datetime)) );
  engine.setData( subjectDef, message.subject );
  engine.setData( bodyDef, message.body );
  engine.setData( attachmentsDef, files );
}

/**
  * config からメール ID を読み出す
  * @return {Stromg} messageId  メール ID
  */
function retrieveMessageId() {
  const messageIdDef = configs.getObject( "conf_messageId" );
  let messageId = configs.get( "conf_messageId" );
  if ( messageIdDef !== null ) {
    messageId = engine.findData( messageIdDef );
  }
  return messageId;
}

/**
  * Gmail のメール取得の URI を決定する
  * メール ID が空であればエラーとする
  * @param {String} messageId  メール ID
  * @return {String} apiUri  API の URI
  */
function determineApiUri( messageId ) {
  if ( messageId === "" || messageId === null ) {
    throw "Message ID is empty.";
  }
  let apiUri = `https://gmail.googleapis.com/gmail/v1/users/me/messages/${encodeURI(messageId)}`;
  return apiUri;
}

/**
  * Gmail REST API にメール取得の GET リクエストを送信し、必要な情報を JSON オブジェクトに格納する
  * @param {String} apiUri  API の URI
  * @param {String} apiToken  API トークン
  * @param {Object} message  メール情報を格納する JSON オブジェクト
  */
function getMessage( apiUri, apiToken, message ) {
  const response = httpClient.begin()
    .bearer( apiToken )
    // .queryParam( "format", "raw" )
    .get( apiUri );

  // when error thrown
  const responseJson = response.getResponseAsString();
  const status = response.getStatusCode();
  if (status >= 300) {
    engine.log(`API URI: ${apiUri}`);
    const accessLog = `---GET request--- ${status}\n${responseJson}\n`;
    engine.log( accessLog );
    throw `Failed to get message. status: ${status}`;
  }

  // when successful, parse the message content
  const json = JSON.parse(responseJson);
  // const rawMessage = base64.decodeFromUrlSafeString(json.raw);

  extractFromPayload( json.payload, message );
}

/**
  * Gmail REST API のメール取得のレスポンスの payload フィールドから
  * 必要な情報を抜き出し、JSON オブジェクトに格納する
  * @param {Object} payload  Gmail REST API のメール取得のレスポンスの payload フィールド
  * @param {Object} message  メール情報を格納する JSON オブジェクト
  */
function extractFromPayload( payload, message ) {
  // ヘッダの処理
  let sender = ""; // From ヘッダが無い場合に Sender ヘッダの値を使う
  payload.headers.forEach( function ( header ) {
    if ( header.name === "From" ) {
      message.from = header.value;
    }
    if ( header.name === "Sender" ) {
      sender = header.value;
    }
    if ( header.name === "To" || header.name === "Cc" || header.name === "Bcc" ) {
      Array.prototype.push.apply( message.recipients, header.value.trim().split(/\s*,\s*/) );
    }
    if ( header.name === "Date" ) {
      message.datetime = header.value;
    }
    if ( header.name === "Subject" ) {
      message.subject = header.value;
    }
  } );
  // From ヘッダが無い、もしくは空文字列の場合は Sender ヘッダの値を使う
  if ( message.from === "" ) {
    message.from = sender;
  }

  // メールアドレスと名前に分ける処理は未実装

  // パート（本文、添付ファイル）の処理
  const mimeType = payload.mimeType;
  if ( mimeType === "text/plain" || mimeType === "text/html" ) { // 本文のみのメール
    message.body = parseTextPart( payload );
    return;
  }
  if ( mimeType.startsWith("multipart/") ) { // マルチパートのメール
    message.body = parseMultiPart( payload, message.attachments );
    return;
  }
}

/**
  * MIME タイプが text/plain, text/html のパートのデータをデコードして文字列として返す
  * @param {Object} part  MIME メールのパート（text/plain または text/html）
  * @return {String} body  パートのデータ（メール本文として保存する文字列の候補）
  */
function parseTextPart( part ) {
  return base64.decodeFromUrlSafeString( part.body.data );
}

/**
  * MIME タイプが multipart/* のパートを再帰的に解析する
  * 添付ファイルのパートがあればその情報を配列に格納したうえで、本文として保存する文字列の候補を返す
  * @param {Object} part  MIME メールのパート（multipart/*）
  * @param attachments {Array<Object>} attachments  添付ファイルの情報（オブジェクト）を格納する配列
  * @return {String} body  メール本文として保存する文字列の候補
  */
function parseMultiPart( part, attachments ) {
  // 本文の候補
  let textPart = null; // 第一候補のパート
  let htmlPart = null; // 第二候補のパート
  let nestedBody = ""; // 第三候補の文字列（下の階層から取得した本文候補、または空文字列）

  part.parts.forEach( function( part, index ) {
    // マルチパートの場合
    if ( part.mimeType.startsWith("multipart/") ) {
      nestedBody = parseMultiPart( part, attachments );
      return;
    }

    // 添付ファイルの場合
    const file = attachment( part, index );
    if ( file !== null ) {
      attachments.push( file );
      return;
    }

    // マルチパートでも添付ファイルでも無い場合は、本文パートの可能性がある
    if ( part.mimeType === "text/plain" ) {
      if ( textPart === null ) { // １つ目の "text/plain" パートを本文パートの第一候補とする
        textPart = part;
      }
      return;
    }
    if ( part.mimeType === "text/html" ) {
      if ( htmlPart === null ) { // １つ目の "text/html" パートを本文パートの第二候補とする
        htmlPart = part;
      }
      return;
    }
  } );

  if ( textPart !== null ) {
    return parseTextPart( textPart );
  }
  if ( htmlPart !== null ) {
    return parseTextPart( htmlPart );
  }
  // "text/plain" パートも "text/html" パートも無い場合は、下の階層から取得した本文、または空文字列
  return nestedBody;
}

/**
  * MIME メールのマルチパート内のパートが添付ファイルかどうかを調べ、添付ファイルであれば
  * その情報をオブジェクトとして返す
  * @param {Object} part  マルチパート内のパート
  * @param index {Number} index  マルチパート内で何番目のパートか
  * @return {Object} file  添付ファイルの情報（添付ファイルのパートでない場合は null）
  */
function attachment( part, index ) {
  const disposition = getDisposition( part );
  const contentType = getContentType( part );

  if ( disposition === null ) {
    return null;
  }
  // マルチパート内の先頭パートは添付ファイルとみなさない
  if ( index === 0 ) {
    return null;
  }
  if ( disposition === "attachment" ) { // ファイル名がなくても添付ファイルとみなす
    let filename = part.filename;
    if ( filename === undefined || filename === null || filename === "" ) {
      filename = "noname"; // Default
    }
    const file = {
        "filename": filename,
        "contentType": contentType,
        "body": part.body
    }
    return file;
  }
  if ( disposition === "inline" ) { // ファイル名がある場合のみ添付ファイルとみなす
    const filename = part.filename;
    if ( filename === undefined || filename === null || filename === "" ) {
      return null;
    }
    const file = {
        "filename": filename,
        "contentType": contentType,
        "body": part.body
    }
    return file;
  }
}

/**
  * MIME メールのパートの "Content-Disposition" ヘッダの値を返す
  * @param {Object} part  パート
  * @return {String} disposition  "Content-Disposition" ヘッダの値（ヘッダが無い場合は null）
  */
function getDisposition( part ) {
  const dispositionHeaders = part.headers.filter( function( header ) {
    if ( header.name === "Content-Disposition" ) {
          return true;
        } 
  } );
  if ( dispositionHeaders.length === 0 ) { // 無い場合は null を返す
    return null;
  }
  return dispositionHeaders[0].value.split(";")[0].toLowerCase();
}

/**
  * MIME メールのパートの "Content-Type" ヘッダの値を返す
  * ヘッダが無い場合はデフォルト値として "application/octet-stream" を返す
  * @param {Object} part  パート
  * @return {String} contentType  "Content-Type" ヘッダの値
  */
function getContentType( part ) {
  const contentTypeHeaders = part.headers.filter( function( header ) {
    if ( header.name === "Content-Type" ) {
          return true;
        } 
  } );
  if ( contentTypeHeaders.length === 0 ) { // 無い場合はデフォルト値を返す
    return "application/octet-stream"; // Default
  }
  return contentTypeHeaders[0].value;
}

/**
  * 添付ファイルの情報に本体データが含まれているかどうかを調べ、
  * ない場合は Gmail REST API に添付ファイル取得の GET リクエストを送信し、
  * 本体データを追加する
  * @param {String} apiUri  API の URI（/messages/{messageId} まで）
  * @param {String} apiToken  API トークン
  * @param {Array<Object>} attachments  添付ファイルの情報（オブジェクト）が格納された配列
  *  配列内の添付ファイルの情報の形式は：
  *   {
  *     "filename": String,
  *     "contentType": String,
  *     "body": {
  *       "data": String(Base64) or "attachmentId": String
  *     }
  *   }
  */
function getAttachments( apiUri, apiToken, attachments ) {
  const httpLimit = httpClient.getRequestingLimit();
  let httpCount = 1; // HTTP リクエストの上限超えチェック用のカウンタ（メール取得のリクエスト後なので初期値は1）
  attachments.forEach( function( attachment ) {
    if ( attachment.body.data === undefined ) { // data がなければ、attachmentId から data を取得して格納
      httpCount++;
      if ( httpCount > httpLimit ) {
        throw "Number of HTTP requests is over the limit";
      }
      const response = httpClient.begin()
        .bearer( apiToken )
        .get( `${apiUri}/attachments/${attachment.body.attachmentId}` );

      // when error thrown
      const responseJson = response.getResponseAsString();
      const status = response.getStatusCode();
      if (status >= 300) {
        engine.log(`API URI: ${apiUri}/attachments/${attachment.body.attachmentId}`);
        const accessLog = `---GET request--- ${status}\n${responseJson}\n`;
        engine.log( accessLog );
        throw `Failed to get attachment. status: ${status}`;
      }

      // when successful, parse the message content
      const json = JSON.parse(responseJson);
      attachment.body["data"] = json.data;
    }
  } );
}

/**
  * 添付ファイルを Qfile に変換し、ファイルの配列に追加する
  * @param {Array<Object>} attachments  添付ファイルの情報（オブジェクト）が格納された配列
  * @param {ListArray<Qfile>} files  ファイルの配列
  */
function convertAndAddAttachments( attachments, files ) {
  attachments.forEach( function( attachment ) {  
    const qfile = new com.questetra.bpms.core.event.scripttask.NewQfile(
      attachment.filename,
      attachment.contentType,
      base64.decodeFromUrlSafeString( attachment.body.data ) // これでは駄目。String ではなく ByteArrayWrapper にデコードしないといけない。
    );
    files.add( qfile );
  } );
}

  ]]>
</script>
<!-- アイコン未設定（Icon Maker に Gmail のアイコンがない）
<icon>

</icon>
-->
</service-task-definition>
