<?xml version="1.0" encoding="UTF-8"?>
<service-task-definition>
    <label>Docraptor: Generate PDF</label>
    <label locale="ja">DocRaptor: PDF 生成</label>
    <last-modified>2023-04-27</last-modified>
    <license>(C) Questetra, Inc. (MIT License)</license>
    <engine-type>3</engine-type>
    <addon-version>2</addon-version>
    <summary>This item generates a PDF file from an HTML file.</summary>
    <summary locale="ja">この工程は、HTML ファイルから PDF ファイルを生成します。</summary>
    <configs>
        <config name="conf_Auth" required="true" form-type="OAUTH2">
            <label>C1: Authorization Setting in which API Key is set</label>
            <label locale="ja">C1: API キーを設定した認証設定</label>
        </config>
        <config name="conf_SourceFiles" required="true" form-type="SELECT" select-data-type="FILE">
            <label>C2: File type data item that stores the source HTML file</label>
            <label locale="ja">C2: 変換元のHTML ファイルが保存されているファイル型データ項目</label>
        </config>
        <config name="conf_Files" required="true" form-type="SELECT" select-data-type="FILE">
            <label>C3: File type data item to save the generated PDF file</label>
            <label locale="ja">C3: 生成された PDF ファイルを追加保存するファイル型データ項目</label>
        </config>
        <config name="conf_DeleteOtherFiles" form-type="TOGGLE">
            <label>C4: Delete other files when saving</label>
            <label locale="ja">C4: 保存時に他のファイルを削除する</label>
        </config>
        <config name="conf_FileName" form-type="TEXTFIELD" required="true" el-enabled="true">
            <label>C5: File name to save as</label>
            <label locale="ja">C5: 保存する際のファイル名</label>
        </config>
    </configs>
    <help-page-url>https://support.questetra.com/bpmn-icons/docraptor-pdf-generate/</help-page-url>
    <help-page-url locale="ja">https://support.questetra.com/ja/bpmn-icons/docraptor-pdf-generate/</help-page-url>

    <script><![CDATA[

const MAX_SOURCE_SIZE = 1048576; // 1MB。一度に文字列として読み出せるファイルサイズの QBPMS の制限から

function main(){
    //// == 工程コンフィグ・ワークフローデータの参照 / Config & Data Retrieving ==
    const apiKey = retrieveApiKey();
    const html = retrieveSourceHtml();
    const filesDef = configs.getObject('conf_Files');
    const deleteOtherFiles = configs.getObject('conf_DeleteOtherFiles');
    const fileName = retrieveFileName();

    //// == 演算 / Calculating ==
    const statusId = generatePdf(apiKey, html);

    // 処理状況を確認し、未完了なら proceed() に進む
    if (checkStatusAndSaveFile(apiKey, statusId, filesDef, deleteOtherFiles, fileName) === false) {
        engine.saveTemporaryData(statusId);
        return false;
    }
}

function proceed() {
    //// == 工程コンフィグ・ワークフローデータの参照 / Config & Data Retrieving ==
    const apiKey = retrieveApiKey();
    const filesDef = configs.getObject('conf_Files');
    const deleteOtherFiles = configs.getObject('conf_DeleteOtherFiles');
    const fileName = retrieveFileName();

    //// == Restoring Temporary Data / 一時データの読み出し ==
    const statusId = engine.restoreTemporaryData();
    if (statusId === null) {
        throw 'Temporary data has not been saved.';
    }

    //// == 演算 / Calculating ==
    if (checkStatusAndSaveFile(apiKey, statusId, filesDef, deleteOtherFiles, fileName) === false) {
        return false;
    }
}

/**
  * 認証設定から API キーを読み出す
  * @return {String} apiKey
  */
function retrieveApiKey() {
    const authSettingName = configs.get('conf_Auth');
    return httpClient.getOAuth2Token(authSettingName);
}

/**
  * config に設定したファイル型データ項目から変換元 HTML を読み出す
  * @return {String} html
  */
function retrieveSourceHtml() {
    const sourceFilesDef = configs.getObject('conf_SourceFiles');
    const sourceFiles = engine.findData(sourceFilesDef);
    if (sourceFiles === null) {
        throw 'No source file attached.';
    }
    if (sourceFiles.size() > 1) {
        throw 'More than one source files attached.';
    }
    const sourceFile = sourceFiles.get(0);
    if (sourceFile.getLength() > MAX_SOURCE_SIZE) {
        throw 'Source file is too large.';
    }
    if (!sourceFile.getContentType().startsWith('text/html')) {
        throw 'Content-Type of the source file is not text/html.';
    }
    // Content-Type の charset 部は無視して、UTF-8 として読み出す
    return fileRepository.readFile(sourceFile, 'UTF-8');
}

/**
  * config から保存する際のファイル名を読み出す
  * 空の場合はエラー
  * @return {String} fileName
  */
function retrieveFileName() {
    const fileName = configs.get('conf_FileName');
    if (fileName === '') {
        throw 'File name is blank.';
    }
    return fileName;
}

/**
  * DocRaptor の PDF 生成 API に POST リクエストを送信し、ステータス ID を返す
  * プロセスがデバッグ実行の場合、PDF 生成をテスト扱いにする
  * @param {String} apiKey  API キー
  * @param {String} html  HTML ソース
  * @return {String} statusId  ステータス ID
  */
function generatePdf(apiKey, html) {
    const requestBody = generateRequestBody(html);
    const response = httpClient.begin()
        .basic(apiKey, 'dummy') // DocRaptor の認証の仕様で、パスワード部は何でも良い
        .body(requestBody, 'application/json')
        .post('https://api.docraptor.com/docs');
    const status = response.getStatusCode();
    const responseStr = response.getResponseAsString();
    if (status !== 200) {
        engine.log(responseStr);
        throw `Failed to post PDF generation request. status: ${status}`;
    }
    return JSON.parse(responseStr).status_id;
}

/**
  * PDF ファイル生成 API のリクエストボディを生成し、JSON 文字列で返す
  * - 非同期生成をリクエスト
  * - プロセスがデバッグ実行の場合、テストリクエスト扱いにする
  * @param {String} html
  * @return {String} requestBody
  */
function generateRequestBody(html) {
    const requestBody = {};
    requestBody.docyment_type = 'pdf';
    requestBody.document_content = html;
    requestBody.async = true; // 非同期生成をリクエストする
    // プロセスがデバッグ実行の場合、test パラメータに true を設定
    if (processInstance.getProcessInstanceDebug()) {
        requestBody.test = true;
    }
    // DocRaptor でログを確認しやすいように名前をつけておく
    requestBody.name = `QBPMS-m${processInstance.getProcessModelInfoId()}-p${processInstance.getProcessInstanceId()}`;
    return JSON.stringify(requestBody);
}

/**
  * PDF ファイル生成の処理状態を確認し、完了していればファイルを保存する
  * 未完了の場合は false を返す
  * @param {String} apiKey  API キー
  * @param {String} statusId  ステータス ID
  * @param {DataDefinitionView} filesDef  ファイルを保存するデータ項目
  * @param {boolean} deleteOtherFiles  添付されている他のファイルを削除するかどうか
  * @param {String} fileName  保存ファイル名
  * @return {boolean}
  */
function checkStatusAndSaveFile(apiKey, statusId, filesDef, deleteOtherFiles, fileName) {
    const response = httpClient.begin()
        .basic(apiKey, 'dummy') // DocRaptor の認証の仕様で、パスワード部は何でも良い
        .get(`https://docraptor.com/status/${statusId}`);
    const status = response.getStatusCode();
    const responseStr = response.getResponseAsString();
    if (status !== 200) {
        engine.log(responseStr);
        throw `Failed to get PDF generation status. status: ${status}`;
    }
    const json = JSON.parse(responseStr);
    if (json.status !== 'completed') {
        return false;
    }
    downloadAndSaveFile(apiKey, json.download_url, filesDef, deleteOtherFiles, fileName);
}

/**
  * PDF ファイルをダウンロードし、を保存する
  * @param {String} apiKey  API キー
  * @param {String} downloadUrl  ダウンロード先 URL
  * @param {DataDefinitionView} filesDef  ファイルを保存するデータ項目
  * @param {boolean} deleteOtherFiles  添付されている他のファイルを削除するかどうか
  * @param {String} fileName  保存ファイル名
  * @return {boolean}
  */
function downloadAndSaveFile(apiKey, downloadUrl, filesDef, deleteOtherFiles, fileName) {
    const response = httpClient.begin()
        .basic(apiKey, 'dummy') // DocRaptor の認証の仕様で、パスワード部は何でも良い
        .get(downloadUrl);
    const status = response.getStatusCode();
    if (status !== 200) {
        engine.log(response.getResponseAsString());
        throw `Failed to download PDF file. status: ${status}`;
    }
    const qfile = new com.questetra.bpms.core.event.scripttask.NewQfile(
        fileName, response.getContentType(), response.getResponse()
    );
    let files = engine.findData(filesDef);
    if (files === null || deleteOtherFiles) {
        files = new java.util.ArrayList();
    }
    files.add(qfile);
    engine.setData(filesDef, files);
}

    ]]></script>

</service-task-definition>
