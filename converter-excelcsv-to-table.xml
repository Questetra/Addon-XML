<?xml version="1.0" encoding="UTF-8"?><service-task-definition>

<label>Converter (Excel-CSV FILE to Table type data)</label>
<label locale="ja">コンバータ (Excel-CSV ファイル to テーブル型データ)</label>

<last-modified>2021-11-11</last-modified>
<help-page-url>https://support.questetra.com/bpmn-icons/converter-excelcsv-to-table/</help-page-url>
<help-page-url locale="ja">https://support.questetra.com/ja/bpmn-icons/converter-excelcsv-to-table/</help-page-url>

<summary>Overwrite the value of a Table type data item with a contents of the Excel compatible CSV file(TSV UTF-16 LE with BOM) stored in a File type data item.</summary>
<summary locale="ja">テーブル型データ項目の値を、ファイル型データ項目に格納されている Excel 対応 CSV ファイル(TSV UTF-16 LE BOM あり)の内容で、上書きします。</summary>


<license>(C) Questetra, Inc. (MIT License)</license>


<configs>
  <config name="File_DataId" required="true" form-type="SELECT" select-data-type="FILE">
    <label>A: File type data item that stores target Excel-CSV file</label>
    <label locale="ja">A: 対象の Excel-CSV が格納されているファイル型データ項目</label>
  </config>
  <config name="Table_DataId" required="true" form-type="SELECT" select-data-type="LIST">
    <label>B: Table type data item to save Excel-CSV data</label>
    <label locale="ja">B: Excel-CSV を保存するテーブル型データ項目</label>
  </config>
</configs>

<engine-type>2</engine-type>

<script><![CDATA[
main();
function main() {
  //// == 自動工程コンフィグの参照 / Config Retrieving ==
  const myFilesDef = configs.getObject("File_DataId"); // (returns ProcessDataDefinitionView)
  const tableDataDef = configs.getObject("Table_DataId"); // (returns ProcessDataDefinitionView)
  const myFiles = engine.findData(myFilesDef);

  // ファイル型データに複数添付されている場合、エラー
  if (myFiles !== null && myFiles.size() > 1) {
    throw new Error("Attachment of multiple files can not be supported.");
  }
  // テーブル型データ項目のために ListArray を作成する
  const myTable = tableDataDef.createListArray();
  // ファイル型データにファイルが1つ添付されている場合
  if (myFiles !== null) {
    // ファイル型を1行ずつ読み込んで、テーブル型にセット
    fileRepository.readFile(myFiles.get(0), "x-UTF-16LE-BOM", function (line) {
      // タブで列分割
      const cellsArray = line.split("\t");
      // ListArray に行を追加する
      const newRow = myTable.addRow();
      // テーブル型データ項目の列数分繰り返す
      for (let j = 0; j < newRow.size(); j++) {
        newRow.setCol(j, cellsArray[j]);
      }
    });
  }

  //// == ワークフローデータへの代入 / Data Updating ==
  // ファイル型データ項目にファイルが1つ添付されている場合はその値、1つも添付されていない場合は空をセット
  engine.setData(tableDataDef, myTable);
}
]]></script>

<test><![CDATA[

/**
 * 1列のテーブル型データ項目の設定の準備
 * @return {{
 *      tableDef: {Object}
 * }}
 */
const prepareTableDef = () => {
  // データ項目を作成
  const tableDef = engine.createDataDefinition(
    "テーブル",
    10,
    "tableDef",
    "LIST"
  );
  // 1列目を文字型データ項目にする
  tableDef.addSubDataDefinition("文字", "string", "STRING");
  return tableDef;
};

/**
 * 複数列のテーブル型データ項目の設定の準備
 * @return {{
 *      multiColumnTableDef: {Object}
 * }}
 */
const prepareTableDefMultiColumn = () => {
  // データ項目を作成
  const multiColumnTableDef = engine.createDataDefinition(
    "テーブル",
    10,
    "tableDef",
    "LIST"
  );
  // 1列目を文字型データ項目にする
  multiColumnTableDef.addSubDataDefinition("文字", "string", "STRING");
  // 2列目を数値型データ項目にする
  multiColumnTableDef.addSubDataDefinition('数値', 'decimal', 'DECIMAL');
  // 3列目を日付型データ項目にする
  multiColumnTableDef.addSubDataDefinition('日付', 'date', 'DATE_YMD');
  // 4列目を選択型データ項目にする
  multiColumnTableDef.addSubDataDefinition('選択', 'select', 'SELECT');
  return multiColumnTableDef;
};

/**
 * 1行1列の正常系
 */
test("success-1row-1column", () => {
  // ファイル型データ項目を準備して、config に指定
  const fileDef = engine.createDataDefinition("ファイル", 5, "q_file", "FILE");
  configs.putObject("File_DataId", fileDef);

  // ArrayList を作成
  let files = new java.util.ArrayList();
  // ArrayList に CSV ファイルを追加
  // 文字コードUTF-16LE-BOM, タブ区切りで"hogehoge"という文字列の「テスト.csv」
  const fileArrayList = engine.createQfile("テスト.csv", "text/tab-separated-values; charset=x-UTF-16LE-BOM","hogehoge")
  files.add(fileArrayList);
  // ファイル型データ項目に値を指定
  engine.setData(fileDef, files);

  // テーブル型データ項目を準備して、config に指定
  const tableDef = prepareTableDef();
  configs.putObject("Table_DataId", tableDef);

  // テーブル型データ項目に ListArray を作成する
  const list = tableDef.createListArray();
  // 新しい行を用意する関数
  list.addRow();
  // テーブル型データ項目に値を指定
  engine.setData(tableDef, list);
  // ファイル型データ項目とテーブル型データ項目の作成を実行
  execute();

  // テーブル型データ項目の値を参照する
  const myTable = engine.findData(tableDef);

  // テーブル型データ項目の値の行数
  const numOfRows = myTable.size(); // 行（Tableの高さ）
  expect(numOfRows).toEqual(1);
  // テーブル型データ項目の値の列数
  const numOfCols = myTable.getRow(0).size(); // 列（Tableの幅）
  expect(numOfCols).toEqual(1);
  // テーブル型データ項目の0行0列目の値がhogehogeであることを確認
  expect(myTable.get(0,0)).toEqual("hogehoge");
});

/**
 * 2行1列の正常系
 */
test("success-2row-1column", () => {
  // ファイル型データ項目を準備して、config に指定
  const fileDef = engine.createDataDefinition("ファイル", 5, "q_file", "FILE");
  configs.putObject("File_DataId", fileDef);

  // ArrayList を作成
  let files = new java.util.ArrayList();
  // ArrayList に CSV ファイルを追加
  // 文字コードUTF-16LE-BOM, タブ区切りで"hogehoge"という文字列の「テスト.csv」
  const fileArrayList = engine.createQfile("テスト.csv", "text/tab-separated-values; charset=x-UTF-16LE-BOM","hogehoge\npiyopiyo")
  files.add(fileArrayList);
  // ファイル型データ項目に値を指定
  engine.setData(fileDef, files);

  // テーブル型データ項目を準備して、config に指定
  const tableDef = prepareTableDef();
  configs.putObject("Table_DataId", tableDef);

  // テーブル型データ項目に ListArray を作成する
  const list = tableDef.createListArray();
  // 新しい行を用意する関数
  list.addRow();
  // テーブル型データ項目に値を指定
  engine.setData(tableDef, list);
  // ファイル型データ項目とテーブル型データ項目の作成を実行
  execute();

  // テーブル型データ項目の値を参照する
  const myTable = engine.findData(tableDef);

  // テーブル型データ項目の値の行数
  const numOfRows = myTable.size(); // 行（Tableの高さ）
  expect(numOfRows).toEqual(2);
  // テーブル型データ項目の値の列数
  const numOfCols = myTable.getRow(0).size(); // 列（Tableの幅）
  expect(numOfCols).toEqual(1);
  // テーブル型データ項目の1行1列目と2行1列目の値がhogehogeであることを確認
  expect(myTable.get(0, 0)).toEqual("hogehoge");
  expect(myTable.get(1, 0)).toEqual("piyopiyo");
});

/**
 * 上書きした2行1列の正常系
 */
test("overwrite-2row-1column", () => {
  // ファイル型データ項目を準備して、config に指定
  const fileDef = engine.createDataDefinition("ファイル", 5, "q_file", "FILE");
  configs.putObject("File_DataId", fileDef);

  // ArrayList を作成
  let files = new java.util.ArrayList();
  // ArrayListに CSV ファイルを追加
  // 文字コードUTF-16LE-BOM, タブ区切りで"hogehoge"という文字列の「テスト.csv」
  const fileArrayList = engine.createQfile("テスト.csv", "text/tab-separated-values; charset=x-UTF-16LE-BOM","hogehoge\npiyopiyo")
  files.add(fileArrayList);
  // ファイル型データ項目に値を指定する
  engine.setData(fileDef, files);

  // テーブル型データ項目を準備して、config に指定
  const tableDef = prepareTableDef();
  configs.putObject("Table_DataId", tableDef);

  // テーブル型データ項目に ListArray を作成する
  const list = tableDef.createListArray();
  // 新しい行を用意する関数
  const newRow = list.addRow();
  // テーブル型データ項目に値を指定
  engine.setData(tableDef, list);
  // ファイル型データ項目とテーブル型データ項目の作成を実行
  execute();

  // テーブル型データ項目の値を参照する
  const myTable = engine.findData(tableDef);

  // テーブル型データ項目の値の行数
  const numOfRows = myTable.size(); // 行（Tableの高さ）
  expect(numOfRows).toEqual(2);
  // テーブル型データ項目の値の列数
  const numOfCols = myTable.getRow(0).size(); // 列（Tableの幅）
  expect(numOfCols).toEqual(1);
  // テーブル型データ項目の1行1列目と2行1列目の値が空白であることを確認
  expect(myTable.get(0, 0)).toEqual("hogehoge");
  expect(myTable.get(1, 0)).toEqual("piyopiyo");
});

/**
 * 1行複数列の正常系
 */
test("success-1row-multicolumns", () => {
  // ファイル型データ項目を準備して、config に指定
  const fileDef = engine.createDataDefinition("ファイル", 5, "q_file", "FILE");
  configs.putObject("File_DataId", fileDef);

  // ArrayList を作成
  let files = new java.util.ArrayList();
  // ArrayList 型に文字コードUTF-16LE-BOM, タブ区切りで複数の型からなる2行2列の「テスト.csv」ファイルを作成。
  const fileArrayList = engine.createQfile("テスト.csv", "text/tab-separated-values; charset=x-UTF-16LE-BOM","hogehoge\t123.45\t2021-10-21\tfalse\n")
  files.add(fileArrayList);
  // ファイル型データ項目をセットする
  engine.setData(fileDef, files);

  // テーブル型データ項目を定義する
  const tableDef = prepareTableDefMultiColumn();
  // テーブル型データ項目を指定する
  configs.putObject("Table_DataId", tableDef);

  // テーブル型データ項目に ListArray を作成する
  const list = tableDef.createListArray();
  // 新しい行を用意する関数
  const addRow = () => {
    const newRow = list.addRow();
  };
  addRow('', '', '', '');
  // テーブル型データ項目に値を指定
  engine.setData(tableDef, list);
  // ファイル型データ項目とテーブル型データ項目の作成を実行
  execute();

  // テーブル型データ項目の値を参照する
  const myTable = engine.findData(tableDef);

  // テーブル型データ項目の値の行数
  const numOfRows = myTable.size(); // 行（Tableの高さ）
  expect(numOfRows).toEqual(1);
  // テーブル型データ項目の値の列数
  const numOfCols = myTable.getRow(0).size(); // 列（Tableの幅）
  expect(numOfCols).toEqual(4);
  // テーブル型データ項目の1行1列目と1行2列目の値がhogehogeであることを確認
  expect(myTable.get(0, 0)).toEqual("hogehoge");
  expect(myTable.get(0, 1)).toEqual("123.45");
  expect(myTable.get(0, 2)).toEqual("2021-10-21");
  expect(myTable.get(0, 3)).toEqual("false");
});

/**
 * 複数行複数列の正常系
 */
test("success-multirows-multicolumns", () => {
  // ファイル型データ項目を準備して、config に指定
  const fileDef = engine.createDataDefinition("ファイル", 5, "q_file", "FILE");
  configs.putObject("File_DataId", fileDef);

  // ArrayList を作成
  let files = new java.util.ArrayList();
  // ArrayList 型に文字コードUTF-16LE-BOM, タブ区切りで複数の型からなる2行2列の「テスト.csv」ファイルを作成。
  const fileArrayList = engine.createQfile("テスト.csv", "text/tab-separated-values; charset=x-UTF-16LE-BOM","hogehoge\t123.45\t2021-10-21\tfalse\npiyopiyo\t42.195\t2022-10-21\ttrue\n")
  files.add(fileArrayList);
  // ファイル型データ項目をセットする
  engine.setData(fileDef, files);

  // テーブル型データ項目を定義する
  const tableDef = prepareTableDefMultiColumn();
  // テーブル型データ項目を指定する
  configs.putObject("Table_DataId", tableDef);

  // テーブル型データ項目に ListArray を作成する
  const list = tableDef.createListArray();
  // 新しい行を用意する関数
  list.addRow();
  // テーブル型データ項目に値を指定
  engine.setData(tableDef, list);
  // ファイル型データ項目とテーブル型データ項目の作成を実行
  execute();

  // テーブル型データ項目の値を参照する
  const myTable = engine.findData(tableDef);

  // テーブル型データ項目の値の行数
  const numOfRows = myTable.size(); // 行（Tableの高さ）
  expect(numOfRows).toEqual(2);
  // テーブル型データ項目の値の列数
  const numOfCols = myTable.getRow(0).size(); // 列（Tableの幅）
  expect(numOfCols).toEqual(4);
  // テーブル型データ項目の1行1列目と1行2列目の値がhogehogeであることを確認
  expect(myTable.get(0, 0)).toEqual("hogehoge");
  expect(myTable.get(0, 1)).toEqual("123.45");
  expect(myTable.get(0, 2)).toEqual("2021-10-21");
  expect(myTable.get(0, 3)).toEqual("false");
  expect(myTable.get(1, 0)).toEqual("piyopiyo");
  expect(myTable.get(1, 1)).toEqual("42.195");
  expect(myTable.get(1, 2)).toEqual("2022-10-21");
  expect(myTable.get(1, 3)).toEqual("true");
});

/**
 * テーブル型データ項目よりも少ない列数
 */
test("few-column", () => {
  // ファイル型データ項目を準備して、config に指定
  const fileDef = engine.createDataDefinition("ファイル", 5, "q_file", "FILE");
  configs.putObject("File_DataId", fileDef);

  // ArrayList を作成
  let files = new java.util.ArrayList();
  // ArrayList に CSV ファイルを追加
  // ArrayList 型に文字コードUTF-16LE-BOM, タブ区切りで複数の型からなる2行2列の「テスト.csv」ファイルを作成。
  const fileArrayList = engine.createQfile("テスト.csv", "text/tab-separated-values; charset=x-UTF-16LE-BOM","hogehoge\t123.45")
  files.add(fileArrayList);
  // ファイル型データ項目をセットする
  engine.setData(fileDef, files);

  // テーブル型データ項目を定義する
  const tableDef = prepareTableDefMultiColumn();
  // テーブル型データ項目を指定する
  configs.putObject("Table_DataId", tableDef);

  // テーブル型データ項目に ListArray を作成する
  const list = tableDef.createListArray();
  // 新しい行を用意する関数
  list.addRow();
  // テーブル型データ項目に値を指定
  engine.setData(tableDef, list);
  // ファイル型データ項目とテーブル型データ項目の作成を実行
  execute();

  // テーブル型データ項目の値を参照する
  const myTable = engine.findData(tableDef);

  // テーブル型データ項目の値の行数
  const numOfRows = myTable.size(); // 行（Tableの高さ）
  expect(numOfRows).toEqual(1);
  // テーブル型データ項目の列数が4である
  const numOfCols = myTable.getRow(0).size(); // 列（Tableの幅）
  expect(numOfCols).toEqual(4);
  // テーブル型データ項目の1行1列目と1行2列目の値がhogehogeであることを確認
  expect(myTable.get(0, 0)).toEqual("hogehoge");
  expect(myTable.get(0, 1)).toEqual("123.45");
  expect(myTable.get(0, 2)).toEqual(null);
  expect(myTable.get(0, 3)).toEqual(null);
});

/**
 * テーブル型データ項目よりも多い列数
 */
test("over-columns", () => {
  // ファイル型データ項目を準備して、config に指定
  const fileDef = engine.createDataDefinition("ファイル", 5, "q_file", "FILE");
  configs.putObject("File_DataId", fileDef);

  // ArrayList を作成
  let files = new java.util.ArrayList();
  // ArrayList に CSV ファイルを追加
  // ArrayList 型に文字コードUTF-16LE-BOM, タブ区切りで複数の型からなる2行2列の「テスト.csv」ファイルを作成。
  const fileArrayList = engine.createQfile("テスト.csv", "text/tab-separated-values; charset=x-UTF-16LE-BOM","hogehoge\t123.45\t2021-10-21\tfalse\thogehoge\n");
  files.add(fileArrayList);
  // ファイル型データ項目をセットする
  engine.setData(fileDef, files);

  // テーブル型データ項目を定義する
  const tableDef = prepareTableDefMultiColumn();
  // テーブル型データ項目を指定する
  configs.putObject("Table_DataId", tableDef);

  // テーブル型データ項目に ListArray を作成する
  const list = tableDef.createListArray();
  // 新しい行を用意する関数
  list.addRow();
  // テーブル型データ項目に値を指定
  engine.setData(tableDef, list);
  // ファイル型データ項目とテーブル型データ項目の作成を実行
  execute();

  // テーブル型データ項目の値を参照する
  const myTable = engine.findData(tableDef);

  // テーブル型データ項目の値の行数
  const numOfRows = myTable.size(); // 行（Tableの高さ）
  expect(numOfRows).toEqual(1);
  // テーブル型データ項目の列数が4である
  const numOfCols = myTable.getRow(0).size(); // 列（Tableの幅）
  expect(numOfCols).toEqual(4);
  // テーブル型データ項目の1行1列目と1行2列目の値がhogehogeであることを確認
  expect(myTable.get(0, 0)).toEqual("hogehoge");
  expect(myTable.get(0, 1)).toEqual("123.45");
  expect(myTable.get(0, 2)).toEqual("2021-10-21");
  expect(myTable.get(0, 3)).toEqual("false");
});

/**
 * 複数ファイル
 */
test("multiple files", () => {
  const fileDef = engine.createDataDefinition("ファイル", 5, "q_file", "FILE");
  configs.putObject("File_DataId", fileDef);

  const files = new java.util.ArrayList();
  fileArrayList1 = engine.createQfile("1.csv", "text/tab-separated-values", "テスト1")
  files.add(fileArrayList1);
  fileArrayList2 = engine.createQfile("2.csv", "text/tab-separated-values", "テスト2")
  files.add(fileArrayList2);
  engine.setData(fileDef, files);

  try {
    execute();
    fail("not come here");
  } catch (e) {
    expect(e.message).endsWith(
      "Attachment of multiple files can not be supported."
    );
  }
});
]]></test>

<icon>
iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAACx0lEQVRYR8WXz0sUYRjHP5O0CLX+
uHTIQ7sHIby0BdIh0EU6hwmd20Vx9mb9AUvlQQSRVhBq0WW3gxcFKzx4000kBKO2QNgSssgS6uDu
oQQJJt4ZZ3ecH+s4O+kLyy7s+z7fz/PM87zPMxKnvKRj6afpBbpRiCDRAkQOzhdQKCEhvvMkeOnW
7tEAWVrYZwi4B6qom1UCUgSYII747bhqAzwhxhkeH0PYLCTE48i8cCJwBnhKCkn13I+VQua+nSF7
gDQ54K4fyhUbCjkSxM02rQD+en5YT2GChJpLlXUYQHvmWV89txq7bcyJKoCW7Vt1JJxb7hIBwnp1
VAHSPAQeuLVSa99U1xTzW/Msflt02vYIWdXDCCBKptkPgI07GzQFmhhcGXSCKCHTWgXQbrjnRvGe
iz20nWvzxJO8lqS9uZ3t39u1INRc0CJgk/nCi47WDk8AxkOOEAcVoQGkyat3vGH5BbD3d4/RwijD
b4fNzrxCJqoDfAEuGXdMd03TeaHTUwRC50NqDgjx8Q/jJN8k7ewUkLmqAyielBwOieiFg+Fa4tpJ
GelIgODZIJnuDDt/dhh67a41rN5aZfnHspPnVWwDgOURiF1CPBvN0hvqJfcxx8DKgH+BUnhPgohj
EhrFG6QG1n6usVne9ASw9H2J3CfR3w4tQxLalOHszVn6wn0I8XpXppixRs9UhpaLaPLGJP2X+2ls
aKxXH1sAMFxE2l1guYqNEHOf51j4uuAJplgqsv5r3Xi2jKyNd0c2Ix1iZnPGzyS0aUZaOxbVYGlI
Y9fH2N3fZeTdiKcImA6VCRCytmOx61QHEh3zf45kUAm9LndyQyk8QyZmfoYnNZZbPK8dAf1fbVAR
V5jXSakMxLy9mOgQWnWIUVp83IIIYfFqlqrv1cz8wEREFKJIRFBoQeKKukU0FokSCgUk8rU8dp8D
flS8Cxv/AFp57iGwqv7bAAAAAElFTkSuQmCC
</icon>

</service-task-definition>