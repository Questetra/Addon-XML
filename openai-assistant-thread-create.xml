<?xml version="1.0" encoding="UTF-8"?>
<service-task-definition>
    <license>(C) Questetra, Inc. (MIT License)</license>
    <!--
    <last-modified>2023-11-20</last-modified>
    -->
    <engine-type>3</engine-type>
    <addon-version>2</addon-version>

    <label>OpenAI Assistant: Thread Create</label>
    <label locale="ja">OpenAI Assistant: スレッド作成</label>

    <help-page-url>https://support.questetra.com/bpmn-icons/service-task-openai-chatgpt-chat/
    </help-page-url>
    <help-page-url locale="ja">https://support.questetra.com/ja/bpmn-icons/service-task-openai-chatgpt-chat/
    </help-page-url>

    <summary>

    </summary>
    <summary locale="ja">

    </summary>

    <configs>
        <config name="conf_Auth" required="true" form-type="OAUTH2"
                auth-type="TOKEN">
            <label>C1: Authorization Setting in which Authentication Key is set
            </label>
            <label locale="ja">C1: 認証キーを設定した認証設定</label>
        </config>
        <config name="conf_AssistantId" required="true">
            <label>C2: Assistant ID</label>
        </config>
        <config name="conf_Message" required="true" el-enabled="true"
                form-type="TEXTAREA">
            <label>U1: User Message</label>
            <label locale="ja">U1: ユーザメッセージ</label>
        </config>
        <config name="conf_Images" required="false" form-type="SELECT"
                select-data-type="FILE">
            <label>I1: Images to attach to</label>
            <label locale="ja">I1: 添付する画像</label>
        </config>
        <config name="conf_Files" required="false" form-type="SELECT"
                select-data-type="FILE">
            <label>I1: Files to attach to</label>
            <label locale="ja">I1: 添付するファイル</label>
        </config>
        <config name="conf_ThreadID" required="true" form-type="SELECT"
                select-data-type="STRING_TEXTFIELD">
            <label>A1: Data item to save Thread ID</label>
            <label locale="ja">A1: スレッド ID を保存するデータ項目</label>
        </config>
        <config name="conf_Answer" required="true" form-type="SELECT"
                select-data-type="STRING">
            <label>A1: Data item to save response from Assistant</label>
            <label locale="ja">A1: Assistant の回答を保存するデータ項目</label>
        </config>
    </configs>

    <script><![CDATA[
const MAX_TOKENS_DEFAULT = 2048;
const MAX_IMAGE_SIZE = 20971520; // ChatGPT の制限。1 ファイルにつき 20 MB まで
const AVAILABLE_IMAGE_TYPES = ['image/jpeg', 'image/png', 'image/gif', 'image/webp'];

const main = () => {
    ////// == 工程コンフィグ・ワークフローデータの参照 / Config & Data Retrieving ==
    const auth = configs.getObject('conf_Auth');   /// REQUIRED
    const assistantId = configs.get('conf_AssistantId');

    const message = configs.get('conf_Message');    /// REQUIRED
    if (message === '') {
        throw new Error('User Message is empty.');
    }
    const imageUrls = retrieveImageUrls('conf_Images');
    const fileIds = uploadFiles(auth, 'conf_Files');

    ////// == 演算 / Calculating ==
    const threadId = createThread(auth);
    const runId = createRun(auth, assistantId, threadId, message, imageUrls, fileIds);
    saveData('conf_ThreadID', threadId);

    const completed = retrieveRun(auth, threadId, runId);
    if (!completed) {
        const tempData = {threadId, runId};
        engine.saveTemporaryData(JSON.stringify(tempData));

        return false;
    }
    const answer = listMessages(auth, threadId);
    ////// == ワークフローデータへの代入 / Data Updating ==
    saveData('conf_Answer', answer ?? '');
}

const proceed = () => {
    const auth = configs.getObject('conf_Auth');   /// REQUIRED
    const tempDataStr = engine.restoreTemporaryData();
    if (tempDataStr === null) {
        throw 'temporary data has not been saved';
    }
    const {threadId, runId} = JSON.parse(tempDataStr);
    const completed = retrieveRun(auth, threadId, runId);
    if (!completed) {
        return false;
    }
    const answer = listMessages(auth, threadId);
    ////// == ワークフローデータへの代入 / Data Updating ==
    saveData('conf_Answer', answer ?? '');
};

/**
 * config から添付画像を読み出し、image_url パラメータに設定する文字列の配列として返す
 * @param configName
 * @returns {Array<String>} imageUrls
 */
const retrieveImageUrls = (configName) => {
    const imagesDef = configs.getObject(configName);
    if (imagesDef === null) {
        return [];
    }
    const images = engine.findData(imagesDef);
    if (images === null) {
        return [];
    }
    const imageUrls = [];
    images.forEach(image => {
        if (image.getLength() > MAX_IMAGE_SIZE) {
            throw new Error(`Attached image "${image.getName()}" is too large. Each file must be less than ${MAX_IMAGE_SIZE} bytes.`);
        }
        const contentType = image.getContentType();
        if (!AVAILABLE_IMAGE_TYPES.includes(contentType)) {
            throw new Error(`Content-Type of "${image.getName()}" is not supported. Supported types are: ${AVAILABLE_IMAGE_TYPES.join(', ')}.`);
        }
        imageUrls.push(`data:${contentType};base64,${base64.encodeToString(fileRepository.readFile(image))}`);
    });
    return imageUrls;
};

const uploadFiles = (auth, configName) => {
    const def = configs.getObject(configName);
    if (def === null) {
        return [];
    }
    const files = engine.findData(def);
    if (files === null) {
        return [];
    }
    const fileIds = [];
    files.stream().forEach(file => {
        const response = httpClient.begin().authSetting(auth)
            .multipart('file', file)
            .multipart('purpose', 'assistants')
            .post('https://api.openai.com/v1/files');
        const responseCode = response.getStatusCode();
        const responseBody = response.getResponseAsString();
        if (responseCode !== 200) {
            engine.log(responseBody);
            throw new Error(`Failed to request. status: ${responseCode}`);
        }
        const responseJson = JSON.parse(responseBody);
        fileIds.push(responseJson.id);
    });
    return fileIds;
};

const createThread = (auth) => {
    const response = httpClient
        .begin()
        .authSetting(auth)
        .header('OpenAI-Beta', 'assistants=v2')
        .post('https://api.openai.com/v1/threads');
    const responseCode = response.getStatusCode();
    const responseBody = response.getResponseAsString();
    if (responseCode !== 200) {
        engine.log(responseBody);
        throw new Error(`Failed to request. status: ${responseCode}`);
    }
    const responseJson = JSON.parse(responseBody);
    return responseJson.id;
};

const createRun= (auth, assistantId, threadId, message, imageUrls, fileIds) => {
    /// prepare json
    const requestJson = {
        assistant_id: assistantId,
        additional_messages: []
    };
    const messageObj = {
        role: 'user',
        content: [{
            type: 'text',
            text: message
        }],
        attachments: []
    };
    imageUrls.forEach(imageUrl => {
        messageObj.content.push({
            type: 'image_url',
            image_url: {
                url: imageUrl
            }
        });
    });
    fileIds.forEach(fileId => {
        messageObj.attachments.push({
            file_id: fileId,
            tools: [{
                type: 'code_interpreter'
            }]
        });
    });
    requestJson.additional_messages.push(messageObj);

    //requestJson.max_tokens = maxTokens;
    engine.log(JSON.stringify(requestJson));

    const response = httpClient.begin().authSetting(auth)
        .header('OpenAI-Beta', 'assistants=v2')
        .body(JSON.stringify(requestJson), 'application/json')
        .post(`https://api.openai.com/v1/threads/${threadId}/runs`);

    const responseCode = response.getStatusCode();
    const responseBody = response.getResponseAsString();
    if (responseCode !== 200) {
        engine.log(responseBody);
        throw new Error(`Failed to request. status: ${responseCode}`);
    }
    const responseJson = JSON.parse(responseBody);
    return responseJson.id;
};

const retrieveRun = (auth, threadId, runId) => {
    const response = httpClient.begin().authSetting(auth)
        .header('OpenAI-Beta', 'assistants=v2')
        .get(`https://api.openai.com/v1/threads/${threadId}/runs/${runId}`);
    const responseCode = response.getStatusCode();
    const responseBody = response.getResponseAsString();
    if (responseCode !== 200) {
        engine.log(responseBody);
        throw new Error(`Failed to request. status: ${responseCode}`);
    }
    const responseJson = JSON.parse(responseBody);
    const completed = responseJson.status === 'completed';
    if (!completed) {
        engine.log(JSON.stringify(responseJson));
    }
    return completed;
};

const listMessages = (auth, threadId) => {
    const response = httpClient.begin().authSetting(auth)
        .header('OpenAI-Beta', 'assistants=v2')
        .get(`https://api.openai.com/v1/threads/${threadId}/messages`);
    const responseCode = response.getStatusCode();
    const responseBody = response.getResponseAsString();
    if (responseCode !== 200) {
        engine.log(responseBody);
        throw new Error(`Failed to request. status: ${responseCode}`);
    }
    const responseJson = JSON.parse(responseBody);
    const text = responseJson.data[0].content[0].text;
    let answer = text.value;
    if (text.annotations??[].length > 0) {
        text.annotations.forEach(annotation => {
            answer += `\n${JSON.stringify(annotation)}`;
        });
    }
    return answer;
};

/**
 * データ項目への保存
 * @param configName
 * @param data
 */
const saveData = (configName, data) => {
    const def = configs.getObject(configName);
    if (def === null) {
        return;
    }
    engine.setData(def, data);
};
]]></script>


    <icon>
        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
        AAAAAElFTkSuQmCC
    </icon>

    <test><![CDATA[
    ]]></test>
</service-task-definition>
