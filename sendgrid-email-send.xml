<?xml version="1.0" encoding="UTF-8"?>
<service-task-definition>
    <engine-type>3</engine-type>
    <addon-version>2</addon-version>
    <last-modified>2023-06-09</last-modified>
    <license>(C) Questetra, Inc. (MIT License)</license>
    <label>Twilio SendGrid: Send Email</label>
    <label locale="ja">Twilio SendGrid: メール送信</label>
    <summary>This item sends emails to the contacts in the specified lists and/or segments on SendGrid.</summary>
    <summary locale="ja">この工程は、SendGrid のリストやセグメントに含まれる宛先に、メールを一斉送信します。</summary>
    <help-page-url>https://support.questetra.com/bpmn-icons/sendgrid-email-send/</help-page-url>
    <help-page-url locale="ja">https://support.questetra.com/ja/bpmn-icons/sendgrid-email-send/</help-page-url>
    <tabs>
        <tab>
            <label>API Key and Email Settings</label>
            <label locale="ja">API キーと送信設定</label>
            <configs>
                <config name="conf_Auth" required="true" form-type="OAUTH2" auth-type="TOKEN">
                    <label>C1: Authorization Setting in which API Key is set as token</label>
                    <label locale="ja">C1: API キーをトークンとして設定した認証設定</label>
                </config>
                <config name="conf_SenderId" required="true" el-enabled="true" form-type="TEXTFIELD">
                    <label>C2: Sender ID</label>
                    <label locale="ja">C2: 送信者 ID</label>
                </config>
                <config name="conf_SendAt" form-type="SELECT" select-data-type="DATETIME">
                    <label>C3: Scheduled Datetime (if blank, sent immediately)</label>
                    <label locale="ja">C3: 送信日時（指定しない場合、即座に送信されます）</label>
                </config>
            </configs>
        </tab>
        <tab>
            <label>Send To</label>
            <label locale="ja">送信先</label>
            <configs>
                <config name="conf_ListIds" el-enabled="true" form-type="TEXTAREA">
                    <label>C4-A: List IDs to send the emails to (write one per line)</label>
                    <label locale="ja">C4-A: メールを送信する宛先リストの ID（複数設定する場合、1 行に 1 つ）</label>
                </config>
                <config name="conf_SegmentIds" el-enabled="true" form-type="TEXTAREA">
                    <label>C4-B: Segment IDs to send the emails to (write one per line)</label>
                    <label locale="ja">C4-B: メールを送信する宛先セグメントの ID（複数設定する場合、1 行に 1 つ）</label>
                </config>
                <config name="conf_UnsubscribeGroupId" required="true" el-enabled="true" form-type="TEXTFIELD">
                    <label>C5: Unsubscribe Group ID</label>
                    <label locale="ja">C5: 配信停止グループ ID</label>
                </config>
            </configs>
        </tab>
        <tab>
            <label>Email Content</label>
            <label locale="ja">メール本文</label>
            <configs>
                <config name="conf_DesignId" el-enabled="true" form-type="TEXTFIELD">
                    <label>C6-A: Design ID</label>
                    <label locale="ja">C6-A: デザイン ID</label>
                </config>
                <config name="conf_HasUniqueContent" form-type="TOGGLE">
                    <label>C6-B: Configure the subject and content without using Design</label>
                    <label locale="ja">C6-B: デザインを使用せず、件名と本文を直接指定する</label>
                </config>
                <config name="conf_Subject" depends-on="conf_HasUniqueContent" required="true" el-enabled="true" form-type="TEXTFIELD">
                    <label>C6-B1: Subject</label>
                    <label locale="ja">C6-B1: 件名</label>
                </config>
                <config name="conf_HtmlContent" depends-on="conf_HasUniqueContent" required="true" el-enabled="true" form-type="TEXTAREA">
                    <label>C6-B2: HTML Content</label>
                    <label locale="ja">C6-B2: HTML メールの本文</label>
                </config>
                <config name="conf_PlainContent" depends-on="conf_HasUniqueContent" el-enabled="true" form-type="TEXTAREA">
                    <label>C6-B3: Plain Text Content (if blank, auto-generated from HTML)</label>
                    <label locale="ja">C6-B3: プレーンテキストメールの本文（指定しない場合、HTML メールの本文から自動生成されます）</label>
                </config>
            </configs>
        </tab>
        <tab>
            <label>Additional Settings</label>
            <label locale="ja">追加設定</label>
            <configs>
                <config name="conf_Categories" el-enabled="true" form-type="TEXTAREA">
                    <label>C7: Categories for filtering logs (write one per line)</label>
                    <label locale="ja">C7: メール送信ログ検索用カテゴリ（複数設定する場合、1 行に 1 つ）</label>
                </config>
                <config name="conf_SingleSendId" form-type="SELECT" select-data-type="STRING_TEXTFIELD">
                    <label>C8: Data item to save ID of the email sending</label>
                    <label locale="ja">C8: メール送信 ID を保存するデータ項目</label>
                </config>
                <config name="conf_SingleSendUrl" form-type="SELECT" select-data-type="STRING_TEXTFIELD">
                    <label>C9: Data item to save URL of the email sending status page</label>
                    <label locale="ja">C9: メール送信ステータス確認ページの URL を保存するデータ項目</label>
                </config>
            </configs>
        </tab>
    </tabs>

    <script><![CDATA[

const MAX_CATEGORY_NUM = 10;
const MAX_CATEGORY_LENGTH = 128;
const MAX_LIST_ID_NUM = 50;
const MAX_SEGMENT_ID_NUM = 10;

function main(){
    //// == Config Retrieving / 工程コンフィグの参照 ==
    const auth = configs.get('conf_Auth');
    const senderId = retrieveIdAsInt('conf_SenderId', 'Sender ID');
    const sendAt = retrieveSendAt();
    const sendTo = retrieveSendTo();
    const unsubscribeGroupId = retrieveIdAsInt('conf_UnsubscribeGroupId', 'Unsubscribe Group ID');
    const content = retrieveContent();
    const categories = retrieveCategories();
    const singleSendIdDef = configs.getObject('conf_SingleSendId');
    const singleSendUrlDef = configs.getObject('conf_SingleSendUrl');

    //// == Calculating / 演算 ==
    const singleSendId = createSingleSend(auth, categories, senderId, sendTo, unsubscribeGroupId, content);
    scheduleSingleSend(auth, singleSendId, sendAt);

    //// == Data Updating / ワークフローデータへの代入 ==
    setData(singleSendIdDef, singleSendId);
    setData(singleSendUrlDef, `https://mc.sendgrid.com/single-sends/${singleSendId}/stats`);
}

/**
  * config に設定されたカテゴリ一覧を読み出す
  * 以下の場合はエラー
  * - 件数が多すぎる
  * - カテゴリが ASCII 文字でないものを含む
  * - 文字数が多すぎる
  * - カテゴリ指定が重複
  * @return {Array<String>} categories
  */
function retrieveCategories() {
    const categories = configs.get('conf_Categories').split('\n')
        .filter(category => category !== '');
    if (categories.length > MAX_CATEGORY_NUM) {
        throw `The maximum number of Categories is ${MAX_CATEGORY_NUM}.`;
    }
    if (!categories.every(isAscii)) {
        throw 'Categories cannot include non-ascii characters.';
    }
    // API ドキュメントに文字数制限の記載はないが、実際には制限がある
    if (categories.some(category => category.length > MAX_CATEGORY_LENGTH)) {
        throw `Each category must be within ${MAX_CATEGORY_LENGTH} characters.`;
    }
    const set = new Set(categories);
    if (categories.length !== set.size) {
        throw 'The same category is set multiple times.';
    }
    return categories;
}

/**
  * 文字列が ASCII 文字だけで構成されているかどうか
  * @param {String} text テストする文字列
  * @return {boolean} 文字列が ASCII 文字だけで構成されているかどうか
  */
function isAscii(text) {
    const reg = new RegExp('^[\x00-\x7F]+$');
    return reg.test(text);
}

/**
  * config に設定された ID を数値として読み出す
  * @param {String} confName 設定名
  * @param {String} label エラーメッセージ用ラベル
  * @return {Number} id
  */
function retrieveIdAsInt(confName, label) {
    const idStr = configs.get(confName);
    if (idStr === '') {
        throw `${label} is blank.`;
    }
    const reg = new RegExp('^\\d+$');
    if (!reg.test(idStr)) {
        throw `${label} must be integer.`;
    }
    return parseInt(idStr, 10);
}

/**
  * config に設定された宛先情報を読み出す
  * @return {Object} sendTo
  * @return {Array<String>} sendTo.listIds
  * @return {Array<String>} sendTo.segmentIds
  */
function retrieveSendTo() {
    const listIds = configs.get('conf_ListIds').split('\n')
        .filter(id => id !== '');
    if (listIds.length > MAX_LIST_ID_NUM) {
        throw `The maximum number of List IDs is ${MAX_LIST_ID_NUM}.`;
    }
    const segmentIds = configs.get('conf_SegmentIds').split('\n')
        .filter(id => id !== '');
    if (segmentIds.length > MAX_SEGMENT_ID_NUM) {
        throw `The maximum number of Segment IDs is ${MAX_SEGMENT_ID_NUM}.`;
    }
    if (listIds.length === 0 && segmentIds.length === 0) {
        throw 'No List IDs or Segment IDs.';
    }
    return {listIds, segmentIds};
}

/**
  * config に設定された送信日時を文字列として読み出す
  * データ項目が選択されていない場合は文字列 now を返す
  * @return {String} sendAt
  */
function retrieveSendAt() {
    const dataDef = configs.getObject('conf_SendAt');
    if (dataDef === null) {
        return 'now';
    }
    const datetime = engine.findData(dataDef); // AddableTimestamp
    if (datetime === null) {
        throw 'Scheduled Datetime is selected but its data is null.';
    }
    if (datetime.getTime() <= Date.now()) {
        throw 'Scheduled Datetime must be future.';
    }
    return dateFormatter.format('UTC', "yyyy-MM-dd'T'HH:mm:ss'Z'", datetime);
}

/**
  * config に設定されたメールの中身の情報を読み出す
  * @return {Object} content メールの中身
  * @return {String} content.designId デザイン ID
  * @return {String} content.subject メールの件名
  * @return {String} content.htmlContent HTML メールの本文
  * @return {String} content.plainContent プレーンテキストメールの本文
  */
function retrieveContent() {
    const designId = configs.get('conf_DesignId');
    const hasUniqueContent = configs.getObject('conf_HasUniqueContent');
    if (!hasUniqueContent) { // デザイン ID を指定する場合
        if (designId === '') {
            throw 'Design ID is blank.';
        }
        return {designId};
    }
    // 件名、本文を直接指定する場合
    if (designId !== '') {
        throw 'Design ID is set while "Configure the subject and content without using Design" is enabled.';
    }
    const subject = configs.get('conf_Subject');
    if (subject === '') {
        throw 'Subject is blank.';
    }
    const htmlContent = configs.get('conf_HtmlContent');
    if (htmlContent === '') {
        throw 'HTML Content is blank.'
    }
    const plainContent = configs.get('conf_PlainContent');
    return {subject, htmlContent, plainContent};
}

/**
  * Single Send のドラフトを作成する
  * @param {String} auth 認証設定名
  * @param {Array<String>} categories カテゴリ一覧
  * @param {Number} senderId 送信者 ID
  * @param {Object} sendTo 宛先情報
  * @param {Array<String>} sendTo.listIds 宛先リストの ID 一覧
  * @param {Array<String>} sendTo.segmentIds 宛先セグメントの ID 一覧
  * @param {Number} unsubscribeGroupId 配信停止グループ ID
  * @param {Object} content メールの中身
  * @return {String} singleSendId
  */
function createSingleSend(auth, categories, senderId, sendTo, unsubscribeGroupId, content) {
    const requestBody = buildRequestBody(categories, senderId, sendTo, unsubscribeGroupId, content);
    const response = httpClient.begin()
        .authSetting(auth)
        .body(JSON.stringify(requestBody), 'application/json')
        .post('https://api.sendgrid.com/v3/marketing/singlesends');
    const status = response.getStatusCode();
    const responseStr = response.getResponseAsString();
    if (status >= 300) {
        engine.log(responseStr);
        throw `Failed to create single send. status: ${status}`;
    }
    return JSON.parse(responseStr).id;
}

/**
  * リクエストボディを作成
  * @param {Array<String>} categories カテゴリ一覧
  * @param {Number} senderId 送信者 ID
  * @param {Object} sendTo 宛先情報
  * @param {Array<String>} sendTo.listIds 宛先リストの ID 一覧
  * @param {Array<String>} sendTo.segmentIds 宛先セグメントの ID 一覧
  * @param {Number} unsubscribeGroupId 配信停止グループ ID
  * @param {Object} content メールの中身
  * @param {String} content.designId デザイン ID
  * @param {String} content.subject メールの件名
  * @param {String} content.htmlContent HTML メールの本文
  * @param {String} content.plainContent プレーンテキストメールの本文
  * @return {Object} requestBody
  */
function buildRequestBody(categories, senderId, sendTo, unsubscribeGroupId, {designId, subject, htmlContent, plainContent}) {
    const emailConfig = {
        sender_id: senderId,
        suppression_group_id: unsubscribeGroupId
    };
    if (designId !== undefined) {
        Object.assign(emailConfig, {
            design_id: designId
        });
    } else {
        Object.assign(emailConfig, {
            subject,
            html_content: htmlContent
        });
        if (plainContent !== '') {
            Object.assign(emailConfig, {
                generate_plain_content: false,
                plain_content: plainContent
            });
        }
    }
    const requestBody = {
        name: `Questetra-m${processInstance.getProcessModelInfoId()}-p${processInstance.getProcessInstanceId()}`,
        categories,
        send_to: {
            list_ids: sendTo.listIds,
            segment_ids: sendTo.segmentIds
        },
        email_config: emailConfig
    };
    return requestBody;
}

/**
  * Single Send の送信予約をする
  * @param {String} auth 認証設定名
  * @param {String} singleSendId 送信設定の ID
  * @param {String} sendAt 送信日時
  */
function scheduleSingleSend(auth, singleSendId, sendAt) {
    const requestBody = {
        send_at: sendAt
    };
    const response = httpClient.begin()
        .authSetting(auth)
        .body(JSON.stringify(requestBody), 'application/json')
        .put(`https://api.sendgrid.com/v3/marketing/singlesends/${singleSendId}/schedule`);

    const status = response.getStatusCode();
    const responseStr = response.getResponseAsString();
    if (status >= 300) {
        engine.log(responseStr);
        throw `Failed to schedule single send. status: ${status}, singleSendId: ${singleSendId}`;
    }
}

/**
  * データ項目にデータを保存する
  * @param {DataDefinitionView} dataDef データ項目の DataDefinitionView
  * @param {Object} value 保存する値
  */
function setData(dataDef, value) {
    if (dataDef !== null) {
        engine.setData(dataDef, value);
    }
}

    ]]></script>

    <icon>
        iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAADBUlEQVRYR8WXS08TURTH/5cWBeXZ
        ipHFjBh3JIYSdKELYePGZCYS4jMxtiauwU+gJm40JpYPYKhxodEoj+4R4lYrjQsXimKrUhKRNxNC
        22vuTMcZ5s50psLgbCY5c++c3zn33PMg+M8PqUh/MnMOFN0gJAKgCQB7s2cKwCIoZe8JyOKo1/+6
        AwwvNCG42g9KB0AIU+r+ULoIQuLI1w2it3mx3IbyAGPfo0DxoWfFVk0qCGKQxBEnCGeAZDYOoN/d
        XA8rKI1DFm/arbQHSGYSALnm4dfel1CagCzGrBt4ABfL+w7V4lhDNae4LkiwmqecPKsU8Ci7pssH
        IQkD5kVbAdiZEzpUzqzJUy04HdrLLfm4mse9z8uc/OzBWlxMzZvktNccEwYAi/bAyle3gHMCSC1t
        ouvNHAfwpDOEq+9/G3IWmIX6I/rtMACS2dsAbrkd6rYBNAV3IAlMHwyAsQy7u427AsC8IIvNBgDL
        cCDDbsrZ9x3yAAAtFjQP2ET+DXE/zrTUcEztddVorani5OO/NvBNySNICIIECBCCKgJMr+Vxf3rF
        zjb1RmgAY9kJEHSbVz3vCuN8ay238ct6AUfHZzn565Mt6Anzt2Mkp6D3rfkWlLZSTEIWenQPzAA4
        7AfAq5yCPjsAVsAkoVMH4DLITnngxayCC+9sPMCslQTiO8Czn+u4nDLlAbObTQC+HcHTH+u4Yk5E
        BkAakhBxDMKXx8OINOzhgq1IKeY2ipz8UmoeoycOcPLhnIK7n/gUDUsQcqV3qCOEWJp3XaV5oExu
        MV1Dm0TkP4A5Eam5YGsq9hWA0iXIotreORYjXwFsi5FWjmf0guQbALO+UN/Gl2P1GIyG5EF7I8LV
        AS6G2vYFwLof6/NheRPX0wse6plTQ6Jv3clmlMf52wfon3avKQV9DEmMWpl2py03BZ13ALVPUEex
        hJdOyfbwWcARRP9tMNH/qI1mA6XRzLVlU7epitXRLL690cxqlpYxe0ARAVGH047SkjQo2Bg2BdCJ
        chZXdgQeLtV2l/wBk2V1MIOcaTsAAAAASUVORK5CYII=
    </icon>

    <test><![CDATA[

/**
 * 設定の準備
 * メールの内容をデザイン ID で指定する場合
 * @param categories
 * @param senderId
 * @param listIds
 * @param segmentIds
 * @param unsubscribeGroupId
 * @param designId
 * @return returnObj
 * @return returnObj.idDef
 * @return returnObj.urlDef
 */
const prepareConfigs = (categories, senderId, listIds, segmentIds, unsubscribeGroupId, designId) => {
    configs.put('conf_Auth', 'SendGrid');
    configs.put('conf_Categories', categories);
    configs.put('conf_SenderId', senderId);
    configs.put('conf_ListIds', listIds);
    configs.put('conf_SegmentIds', segmentIds);
    configs.put('conf_UnsubscribeGroupId', unsubscribeGroupId);
    configs.put('conf_DesignId', designId);

    // ID を保存するデータ項目を作成し、設定
    const idDef = engine.createDataDefinition('ID 保存先', 1, 'q_id', 'STRING_TEXTFIELD');
    engine.setData(idDef, '事前文字列');
    configs.putObject('conf_SingleSendId', idDef);

    // URL を保存するデータ項目を作成し、設定
    const urlDef = engine.createDataDefinition('URL 保存先', 2, 'q_url', 'STRING_TEXTFIELD');
    engine.setData(urlDef, '事前文字列');
    configs.putObject('conf_SingleSendUrl', urlDef);

    return {idDef, urlDef};
};

/**
 * 異常系のテスト
 * @param func
 * @param errorMsg
 */
const assertError = (func, errorMsg) => {
    try {
        func();
        fail();
    } catch (e) {
        expect(e.toString()).toEqual(errorMsg);
    }
};

/**
 * 指定個数のデータを改行区切りにした文字列を生成する
 * @param num
 * @return string
 */
const createListString = (num) => {
    let string = '';
    for (let i = 0; i < num; i++) {
        string += `item${i}\n`;
    }
    return string;
};

/**
 * 指定の長さの文字列を作成
 * @param length
 * @return string
 */
const createString = (length) => {
    const sourceStr = 'abcdefghijklmnopqrstuvwxyz';
    const string = sourceStr.repeat(Math.floor(length / sourceStr.length))
        + sourceStr.slice(0, length % sourceStr.length);
    return string;
}

/**
 * カテゴリの個数が多すぎる
 */
test('Too many Categories', () => {
    const categoriesStr = createListString(MAX_CATEGORY_NUM + 1);
    prepareConfigs(categoriesStr, '123', 'list1\nlist2', 'segment1\nsegment2', '456', 'design1');
    assertError(main, `The maximum number of Categories is ${MAX_CATEGORY_NUM}.`);
});

/**
 * カテゴリに ASCII 文字以外を含む
 */
test('Categories include invalid characters', () => {
    prepareConfigs('categoryあ', '123', 'list1\nlist2', 'segment1\nsegment2', '456', 'design1');
    assertError(main, 'Categories cannot include non-ascii characters.');
});

/**
 * 長すぎるカテゴリを含む
 */
test('Category is loo long', () => {
    const categoriesStr = createListString(MAX_CATEGORY_NUM - 1) + createString(MAX_CATEGORY_LENGTH + 1);
    prepareConfigs(categoriesStr, '123', 'list1\nlist2', 'segment1\nsegment2', '456', 'design1');
    assertError(main, `Each category must be within ${MAX_CATEGORY_LENGTH} characters.`);
});

/**
 * カテゴリの指定が重複
 */
test('Same category is set multiple times', () => {
    const categoriesStr = createListString(MAX_CATEGORY_NUM - 1) + 'item1';
    prepareConfigs(categoriesStr, '123', 'list1\nlist2', 'segment1\nsegment2', '456', 'design1');
    assertError(main, 'The same category is set multiple times.');
});

/**
 * 送信者 ID が空
 */
test('Sender ID is blank', () => {
    prepareConfigs('', '', 'list1\nlist2', 'segment1\nsegment2', '123', 'design1');
    assertError(main, 'Sender ID is blank.');
});

/**
 * 送信者 ID が整数でない
 */
test('Sender ID is not integer', () => {
    prepareConfigs('', 'invalidId', 'list1\nlist2', 'segment1\nsegment2', '123', 'design1');
    assertError(main, 'Sender ID must be integer.');
});

/**
 * 配信停止グループ ID が空
 */
test('Unsubscribe Group ID is blank', () => {
    prepareConfigs('', '123', 'list1\nlist2', 'segment1\nsegment2', '', 'design1');
    assertError(main, 'Unsubscribe Group ID is blank.');
});

/**
 * 配信停止グループ ID が整数でない
 */
test('Unsubscribe Group ID is not integer', () => {
    prepareConfigs('', '123', 'list1\nlist2', 'segment1\nsegment2', 'invalidId', 'design1');
    assertError(main, 'Unsubscribe Group ID must be integer.');
});

/**
 * リスト ID とセグメント ID がどちらも空
 */
test('No List IDs or Segment IDs', () => {
    prepareConfigs('', '123', '', '', '456', 'design1');
    assertError(main, 'No List IDs or Segment IDs.');
});

/**
 * リスト ID の個数が多すぎる
 */
test('Too many List IDs', () => {
    const listIdsStr = createListString(MAX_LIST_ID_NUM + 1);
    prepareConfigs('', '123', listIdsStr, '', '456', 'design1');
    assertError(main, `The maximum number of List IDs is ${MAX_LIST_ID_NUM}.`);
});

/**
 * セグメント ID の個数が多すぎる
 */
test('Too many Segment IDs', () => {
    const segmentIdsStr = createListString(MAX_SEGMENT_ID_NUM + 1);
    prepareConfigs('', '123', '', segmentIdsStr, '456', 'design1');
    assertError(main, `The maximum number of Segment IDs is ${MAX_SEGMENT_ID_NUM}.`);
});

/**
 * デザイン ID が空
 */
test('Design ID is blank', () => {
    prepareConfigs('', '123', 'list1\nlist2', 'segment1\nsegment2', '456', '');
    assertError(main, 'Design ID is blank.');
});

/**
 * Single Send のドラフトを作成する API リクエストのテスト
 * @param {Object} request
 * @param request.url
 * @param request.method
 * @param request.contentType
 * @param request.body
 * @param categories
 * @param senderId
 * @param listIds
 * @param segmentIds
 * @param unsubscribeGroupId
 * @param designId
 * @param subject
 * @param htmlContent
 * @param plainContent
 */
const assertCreateRequest = ({url, method, contentType, body}, categories, senderId, listIds, segmentIds, unsubscribeGroupId, designId, subject, htmlContent, plainContent) => {
    expect(url).toEqual('https://api.sendgrid.com/v3/marketing/singlesends');
    expect(method).toEqual('POST');
    expect(contentType).toEqual('application/json');
    const bodyObj = JSON.parse(body);
    expect(bodyObj.name).toEqual(`Questetra-m${processInstance.getProcessModelInfoId()}-p${processInstance.getProcessInstanceId()}`);
    expect(bodyObj.categories).toEqual(categories);
    expect(bodyObj.send_to.list_ids).toEqual(listIds);
    expect(bodyObj.send_to.segment_ids).toEqual(segmentIds);
    expect(bodyObj.email_config.sender_id).toEqual(senderId);
    expect(bodyObj.email_config.suppression_group_id).toEqual(unsubscribeGroupId);
    expect(bodyObj.email_config.design_id).toEqual(designId);
    expect(bodyObj.email_config.subject).toEqual(subject);
    expect(bodyObj.email_config.html_content).toEqual(htmlContent);
    expect(bodyObj.email_config.plain_content).toEqual(plainContent);
    if (plainContent !== undefined) {
        expect(bodyObj.email_config.generate_plain_content).toEqual(false);
    }
};

/**
 * Single Send のドラフトを作成する API リクエストでエラー
 */
test('Fail to create Single Send', () => {
    prepareConfigs('', '123', 'list1\nlist2', 'segment1\nsegment2', '456', 'design1');

    httpClient.setRequestHandler((request) => {
        assertCreateRequest(request, [], 123, ['list1', 'list2'], ['segment1', 'segment2'], 456, 'design1', undefined, undefined, undefined);
        return httpClient.createHttpResponse(400, 'application/json', '{}');
    });

    assertError(main, 'Failed to create single send. status: 400');
});

/**
 * Single Send の送信予約をする API リクエストのテスト
 * @param {Object} request
 * @param request.url
 * @param request.method
 * @param request.contentType
 * @param request.body
 * @param singleSendId
 * @param sendAt
 */
const assertScheduleRequest = ({url, method, contentType, body}, singleSendId, sendAt) => {
    expect(url).toEqual(`https://api.sendgrid.com/v3/marketing/singlesends/${singleSendId}/schedule`);
    expect(method).toEqual('PUT');
    expect(contentType).toEqual('application/json');
    const bodyObj = JSON.parse(body);
    expect(bodyObj.send_at).toEqual(sendAt);
};

/**
 * Single Send の送信予約をする API リクエストでエラー
 */
test('Fail to schedule Single Send', () => {
    prepareConfigs('', '123', 'list1\nlist2', 'segment1\nsegment2', '456', 'design1');

    let reqCount = 0;
    httpClient.setRequestHandler((request) => {
        if (reqCount === 0) {
            assertCreateRequest(request, [], 123, ['list1', 'list2'], ['segment1', 'segment2'], 456, 'design1', undefined, undefined, undefined);
            reqCount++;
            return httpClient.createHttpResponse(200, 'application/json', '{"id": "singleSend1"}');
        }
        assertScheduleRequest(request, 'singleSend1', 'now');
        return httpClient.createHttpResponse(400, 'application/json', '{}');
    });

    assertError(main, 'Failed to schedule single send. status: 400, singleSendId: singleSend1');
});

/**
 * 成功
 * デザイン ID で指定
 * カテゴリ指定なし
 * 送信日時指定なし
 */
test('Succeed - Content set by design ID, no categories, no schduled datetime', () => {
    const {idDef, urlDef} = prepareConfigs('', '123', 'list1\nlist2', 'segment1\nsegment2', '456', 'design1');

    let reqCount = 0;
    httpClient.setRequestHandler((request) => {
        if (reqCount === 0) {
            assertCreateRequest(request, [], 123, ['list1', 'list2'], ['segment1', 'segment2'], 456, 'design1', undefined, undefined, undefined);
            reqCount++;
            return httpClient.createHttpResponse(200, 'application/json', '{"id": "singleSend1"}');
        }
        assertScheduleRequest(request, 'singleSend1', 'now');
        return httpClient.createHttpResponse(200, 'application/json', '{}');
    });

    main();

    // データ項目の値をチェック
    expect(engine.findData(idDef)).toEqual('singleSend1');
    expect(engine.findData(urlDef)).toEqual('https://mc.sendgrid.com/single-sends/singleSend1/stats');
});

/**
 * 送信日時を設定
 * @param timestamp
 */
const setSendAt = (timestamp) => {
    const def = engine.createDataDefinition('送信日時', 3, 'q_sendAt', 'DATETIME');
    if (timestamp !== null) {
        engine.setData(def, timestamp);
    }
    configs.putObject('conf_SendAt', def);
}

/**
 * 送信日時が選択されているのに、値が空
 */
test('Scheduled Datetime is null', () => {
    prepareConfigs('', '123', 'list1\nlist2', 'segment1\nsegment2', '456', 'design1');
    setSendAt(null);
    assertError(main, 'Scheduled Datetime is selected but its data is null.');
});

/**
 * 送信日時が過去
 */
test('Scheduled Datetime has passed', () => {
    prepareConfigs('', '123', 'list1\nlist2', 'segment1\nsegment2', '456', 'design1');
    const timestamp = new com.questetra.bpms.util.AddableTimestamp().addMinutes(-1);
    setSendAt(timestamp);
    assertError(main, 'Scheduled Datetime must be future.');
});

/**
 * 成功
 * デザイン ID で指定
 * リストのみ指定し、セグメント指定なし
 * カテゴリ指定あり
 * 送信日時指定あり
 */
test('Succeed - Content set by design ID, no segments, with categories, with schduled datetime', () => {
    const {idDef, urlDef} = prepareConfigs('category1\ncategory2\ncategory3', '1', 'list1', '', '4', 'design2');
    const timestamp = new com.questetra.bpms.util.AddableTimestamp().addMinutes(3);
    setSendAt(timestamp);

    let reqCount = 0;
    httpClient.setRequestHandler((request) => {
        if (reqCount === 0) {
            assertCreateRequest(request, ['category1', 'category2', 'category3'], 1, ['list1'], [], 4, 'design2', undefined, undefined, undefined);
            reqCount++;
            return httpClient.createHttpResponse(200, 'application/json', '{"id": "singleSend2"}');
        }
        assertScheduleRequest(request, 'singleSend2', dateFormatter.format('UTC', "yyyy-MM-dd'T'HH:mm:ss'Z'", timestamp));
        return httpClient.createHttpResponse(200, 'application/json', '{}');
    });

    main();

    // データ項目の値をチェック
    expect(engine.findData(idDef)).toEqual('singleSend2');
    expect(engine.findData(urlDef)).toEqual('https://mc.sendgrid.com/single-sends/singleSend2/stats');
});

/**
 * 成功
 * デザイン ID で指定
 * セグメントのみ指定し、リスト指定なし
 * カテゴリ指定あり
 * 送信日時指定なし
 * データ項目に保存しない
 */
test('Succeed - Content set by design ID, no lists, with categories, no schduled datetime, not save', () => {
    const {idDef, urlDef} = prepareConfigs('category1', '1000', '', 'segment1', '4000', 'design3');
    configs.put('conf_SingleSendId', '');
    configs.put('conf_SingleSendUrl', '');

    let reqCount = 0;
    httpClient.setRequestHandler((request) => {
        if (reqCount === 0) {
            assertCreateRequest(request, ['category1'], 1000, [], ['segment1'], 4000, 'design3', undefined, undefined, undefined);
            reqCount++;
            return httpClient.createHttpResponse(200, 'application/json', '{"id": "singleSend3"}');
        }
        assertScheduleRequest(request, 'singleSend3', 'now');
        return httpClient.createHttpResponse(200, 'application/json', '{}');
    });

    main();

    // データ項目の値をチェック
    expect(engine.findData(idDef)).toEqual('事前文字列');
    expect(engine.findData(urlDef)).toEqual('事前文字列');
});

/**
 * 成功
 * デザイン ID で指定
 * カテゴリ、リスト ID、セグメント ID を最大個数指定し、API リクエストの確認を省略
 */
test('Succeed - Maximum number of categories, listIds and segmentIds', () => {
    const categoriesStr = createListString(MAX_CATEGORY_NUM - 1) + createString(MAX_CATEGORY_LENGTH);
    const listIdsStr = createListString(MAX_LIST_ID_NUM);
    const segmentIdsStr = createListString(MAX_SEGMENT_ID_NUM);
    const {idDef, urlDef} = prepareConfigs(categoriesStr, '1', listIdsStr, segmentIdsStr, '4', 'design2');

    let reqCount = 0;
    httpClient.setRequestHandler((request) => {
        if (reqCount === 0) {
            // API リクエストの確認を省略
            reqCount++;
            return httpClient.createHttpResponse(200, 'application/json', '{"id": "singleSend1"}');
        }
        assertScheduleRequest(request, 'singleSend1', 'now');
        return httpClient.createHttpResponse(200, 'application/json', '{}');
    });

    main();

    // データ項目の値をチェック
    expect(engine.findData(idDef)).toEqual('singleSend1');
    expect(engine.findData(urlDef)).toEqual('https://mc.sendgrid.com/single-sends/singleSend1/stats');
});

/**
 * 「デザインを使用せず、件名と本文を直接指定する」がオンなのに、デザイン ID が指定されている
 */
test('Design ID is set while hasUniqueContent is enabled', () => {
    prepareConfigs('', '123', 'list1\nlist2', 'segment1\nsegment2', '456', 'design1');
    configs.putObject('conf_HasUniqueContent', true);
    assertError(main, 'Design ID is set while "Configure the subject and content without using Design" is enabled.');
});

/**
 * 本文を直接指定
 * @param subject
 * @param htmlContent
 * @param plainContent
 */
const setUniqueContent = (subject, htmlContent, plainContent) => {
    configs.put('conf_Subject', subject);
    configs.put('conf_HtmlContent', htmlContent);
    configs.put('conf_PlainContent', plainContent);
}

/**
 * 「デザインを使用せず、件名と本文を直接指定する」がオンなのに、件名が空
 */
test('Subject is blank', () => {
    prepareConfigs('', '123', 'list1\nlist2', 'segment1\nsegment2', '456', '');
    configs.putObject('conf_HasUniqueContent', true);
    setUniqueContent('', 'メールの HTML 本文', '');
    assertError(main, 'Subject is blank.');
});

/**
 * 「デザインを使用せず、件名と本文を直接指定する」がオンなのに、HTML 本文が空
 */
test('HTML Content is Blank', () => {
    prepareConfigs('', '123', 'list1\nlist2', 'segment1\nsegment2', '456', '');
    configs.putObject('conf_HasUniqueContent', true);
    setUniqueContent('メールの件名', '', '');
    assertError(main, 'HTML Content is blank.');
});

/**
 * 成功
 * 件名、本文を直接指定
 * プレーンテキストメールの本文は指定なし
 */
test('Succeed - Has unique content, without plain text content', () => {
    const {idDef, urlDef} = prepareConfigs('', '1', 'list1', '', '4', '');
    configs.putObject('conf_HasUniqueContent', true);
    const subject = 'メールの件名';
    const htmlContent = 'HTML メールの本文\nこれは HTML メールの本文です';
    setUniqueContent(subject, htmlContent, '');

    let reqCount = 0;
    httpClient.setRequestHandler((request) => {
        if (reqCount === 0) {
            assertCreateRequest(request, [], 1, ['list1'], [], 4, undefined, subject, htmlContent, undefined);
            reqCount++;
            return httpClient.createHttpResponse(200, 'application/json', '{"id": "singleSend4"}');
        }
        assertScheduleRequest(request, 'singleSend4', 'now');
        return httpClient.createHttpResponse(200, 'application/json', '{}');
    });

    main();

    // データ項目の値をチェック
    expect(engine.findData(idDef)).toEqual('singleSend4');
    expect(engine.findData(urlDef)).toEqual('https://mc.sendgrid.com/single-sends/singleSend4/stats');
});

/**
 * 成功
 * 件名、本文を直接指定
 * プレーンテキストメールの本文の指定あり
 */
test('Succeed - Has unique content, with plain text content', () => {
    const {idDef, urlDef} = prepareConfigs('', '1', 'list1', '', '4', '');
    configs.putObject('conf_HasUniqueContent', true);
    const subject = 'メールの件名';
    const htmlContent = 'HTML メールの 本文\nこれは HTML メールの本文です';
    const plainContent = 'プレーンテキストメールの本文\nこれはプレーンテキストメールの本文です';
    setUniqueContent(subject, htmlContent, plainContent);

    let reqCount = 0;
    httpClient.setRequestHandler((request) => {
        if (reqCount === 0) {
            assertCreateRequest(request, [], 1, ['list1'], [], 4, undefined, subject, htmlContent, plainContent);
            reqCount++;
            return httpClient.createHttpResponse(200, 'application/json', '{"id": "singleSend5"}');
        }
        assertScheduleRequest(request, 'singleSend5', 'now');
        return httpClient.createHttpResponse(200, 'application/json', '{}');
    });

    main();

    // データ項目の値をチェック
    expect(engine.findData(idDef)).toEqual('singleSend5');
    expect(engine.findData(urlDef)).toEqual('https://mc.sendgrid.com/single-sends/singleSend5/stats');
});

    ]]></test>

</service-task-definition>
