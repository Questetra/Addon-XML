<?xml version="1.0" encoding="UTF-8"?>
<service-task-definition>
    <engine-type>3</engine-type>
    <addon-version>2</addon-version>
    <label>Google Vertex AI: Gemini: Chat</label>
    <label locale="ja">Google Vertex AI: Gemini: チャット</label>
    <last-modified>2025-05-16</last-modified>
    <license>(C) Questetra, Inc. (MIT License)</license>
    <summary>This item sends a message to a Gemini model on Google Vertex AI
        and stores the response in the specified data item.</summary>
    <summary locale="ja">この工程は、Google Vertex AI 上で動作する Gemini
        のモデルにメッセージを送信し、回答をデータ項目に保存します。
    </summary>
    <help-page-url>https://support.questetra.com/bpmn-icons/service-task-google-vertexai-gemini-chat/</help-page-url>
    <help-page-url locale="ja">https://support.questetra.com/ja/bpmn-icons/service-task-google-vertexai-gemini-chat/</help-page-url>
    <configs>
        <config name="conf_Auth" required="true" form-type="OAUTH2" auth-type="OAUTH2_JWT_BEARER">
            <label>C1: Service Account Setting</label>
            <label locale="ja">C1: サービスアカウント設定</label>
        </config>
        <config name="conf_Region" required="true" form-type="TEXTFIELD">
            <label>C2: Region Code</label>
            <label locale="ja">C2: リージョンコード</label>
        </config>
        <config name="conf_ProjectId" required="true" form-type="TEXTFIELD">
            <label>C3: Project ID</label>
            <label locale="ja">C3: プロジェクト ID</label>
        </config>
        <config name="conf_Model" required="true" form-type="SELECT_ITEM" editable="true">
            <label>C4: Model</label>
            <label locale="ja">C4: モデル</label>
            <item value="gemini-2.0-flash">
                <label>Gemini 2.0 Flash</label>
            </item>
            <item value="gemini-2.0-flash-lite">
                <label>Gemini 2.0 Flash Lite</label>
            </item>
        </config>
        <config name="conf_MaxTokens" required="false" form-type="TEXTFIELD">
            <label>C5: Maximum number of tokens to consume (model default if blank)</label>
            <label locale="ja">C5: 使用するトークン数の上限（空白の場合、モデルのデフォルト値）</label>
        </config>
        <config name="conf_Temperature" required="false" form-type="TEXTFIELD">
            <label>C6: Temperature (0.0 - 2.0) (model default if blank)</label>
            <label locale="ja">C6: 温度（0.0 〜 2.0）（空白の場合、モデルのデフォルト値）</label>
        </config>
        <config name="conf_StopSequences" required="false" form-type="TEXTAREA">
            <label>C7: Stop Sequences (write one per line, up to five)</label>
            <label locale="ja">C7: 停止シーケンス（1 行に 1 つ、最大 5 つ）</label>
        </config>
        <config name="conf_Message1" required="true" el-enabled="true"
                form-type="TEXTAREA">
            <label>U1: User Message</label>
            <label locale="ja">U1: ユーザメッセージ</label>
        </config>
        <config name="conf_Images1" required="false" form-type="SELECT"
                select-data-type="FILE">
            <label>I1: Images / videos / audios / PDFs to attach to user message</label>
            <label locale="ja">I1: ユーザメッセージに添付する画像／動画／音声／PDF</label>
        </config>
        <config name="conf_Answer1" required="true" form-type="SELECT"
                select-data-type="STRING_MULTILINE">
            <label>A1: Data item to save response</label>
            <label locale="ja">A1: 回答を保存するデータ項目</label>
        </config>
    </configs>

    <script><![CDATA[

const MAX_IMAGE_SIZE = 20971520; // Gemini のインラインファイルの制限。1 ファイルにつき 20 MB まで

function main() {
	////// == 工程コンフィグ・ワークフローデータの参照 / Config & Data Retrieving ==
	const auth = configs.getObject('conf_Auth');

	const region = retrieveRegion();
	const projectId = configs.get('conf_ProjectId');
	const model = retrieveModel();
	const maxTokens = retrieveMaxTokens();
	const temperature = retrieveTemperature();
	const stopSequences = retrieveStopSequences();
	const message = configs.get('conf_Message1');
	if (message === '') {
		throw new Error('User Message is empty.');
	}
	const inlineImages = retrieveImages();

	////// == 演算 / Calculating ==
	const answer = invokeModel(
		auth,
		region,
		projectId,
		model,
		maxTokens,
		temperature,
		stopSequences,
		message,
		inlineImages
	);

	////// == ワークフローデータへの代入 / Data Updating ==
	saveData('conf_Answer1', answer);
}

/**
 * config からリージョンコードを読み出す
 * リージョンコードの形式として不正な場合はエラー
 * @return {String}
 */
function retrieveRegion() {
	const region = configs.get('conf_Region');
	// 今後リージョンが増えることも考えて、文字数には余裕をみている
	const reg = new RegExp('^[a-z]{2,20}-[a-z]{2,20}[1-9]{1,2}$');
	if (!reg.test(region)) {
		throw new Error('Region Code is invalid.');
	}
	return region;
}

/**
 * config からモデル ID を読み出す
 * モデル ID として不正な文字が含まれている場合はエラー
 * @return {String}
 */
function retrieveModel() {
	const model = configs.get('conf_Model');
	const reg = new RegExp('^[a-z0-9.-]+$');
	if (!reg.test(model)) {
		throw new Error('Model includes an invalid character.');
	}
	return model;
}

/**
 * config から最大トークン数を読み出す
 * 未定義の場合、null を返す
 * @returns {Number}
 */
const retrieveMaxTokens = () => {
	const maxTokens = configs.get('conf_MaxTokens');
	if (maxTokens === '') {
		return null;
	}
	const regExp = new RegExp(/^[1-9][0-9]*$/);
	if (!regExp.test(maxTokens)) {
		throw new Error('Maximum number of tokens must be a positive integer.');
	}
	return parseInt(maxTokens, 10);
};

/**
 * config から温度を読み出す
 * 未定義の場合、null を返す
 * @returns {Number}
 */
const retrieveTemperature = () => {
	const temperature = configs.get('conf_Temperature');
	if (temperature === '') {
		return null;
	}
	const regExp = /^([0-1](\.\d+)?|2(\.0+)?)$/;
	if (!regExp.test(temperature)) {
		throw new Error('Temperature must be a number from 0 to 2.');
	}
	return parseFloat(temperature);
};

/**
 * config から停止シーケンスを読み出す
 * @returns {Array<String>}
 */
const retrieveStopSequences = () => {
	const stopSequencesStr = configs.get('conf_StopSequences');
	if (stopSequencesStr === '') {
		return [];
	}
	const stopSequences = stopSequencesStr.split('\n').filter((s) => s !== '');
	if (stopSequences.length > 5) {
		throw new Error('Too many stop sequences. The maximum number is 5.');
	}
	return stopSequences;
};

/**
 * config から画像・動画を読み出す
 * 以下の場合はエラー
 * - 添付ファイルの総数が多すぎる場合
 * - ファイルサイズが大きすぎる場合
 * - 画像でも動画でもないファイルが添付されている場合
 * @returns {Array<Object>} インライン画像・動画オブジェクトの配列
 */
const retrieveImages = () => {
	const imagesDef = configs.getObject('conf_Images1');
	if (imagesDef === null) {
		return [];
	}
	const images = engine.findData(imagesDef);
	if (images === null) {
		return [];
	}
	const inlineImages = [];
	images.forEach((image) => {
		if (image.getLength() > MAX_IMAGE_SIZE) {
			throw new Error(
				`Attached file "${image.getName()}" is too large. Each file must be less than ${MAX_IMAGE_SIZE} bytes.`
			);
		}
		const contentType = image.getContentType();
		if (
			!contentType.startsWith('image/') &&
			!contentType.startsWith('video/') &&
			!contentType.startsWith('audio/') &&
			!contentType.startsWith('application/pdf')
		) {
			throw new Error(
				`Attached file "${image.getName()}" is neither an image, video, audio, nor PDF.`
			);
		}
		const inlineImage = {
			mimeType: image.getContentType(),
			data: base64.encodeToString(fileRepository.readFile(image)),
		};
		inlineImages.push(inlineImage);
	});
	return inlineImages;
};

const SCOPE = 'https://www.googleapis.com/auth/cloud-platform';
const URL_TOKEN_REQUEST = 'https://oauth2.googleapis.com/token';

/**
 * @param auth HTTP 認証設定
 * @returns {any} アクセストークンを含むオブジェクト
 */
const getAccessToken = (auth) => {
	const privateKeyId = auth.getPrivateKeyId();
	const privateKey = auth.getPrivateKey();
	const serviceAccount = auth.getCustomSecret1();
	const scope = auth.getScope();
	if (scope === null || !scope.split(' ').includes(SCOPE)) {
		throw new Error(`Scope ${SCOPE} must be included in the scope.`);
	}
	if (privateKeyId === '') {
		throw new Error('Private Key ID is required.');
	}
	if (privateKey === '') {
		throw new Error('Private Key is required.');
	}
	if (serviceAccount === '') {
		throw new Error('Service Account must be set to Custom Secret 1.');
	}
	const header = {
		alg: 'RS256',
		typ: 'at+jwt',
		kid: privateKeyId,
	};
	const now = Math.floor(Date.now() / 1000);
	const payload = {
		iss: serviceAccount,
		aud: URL_TOKEN_REQUEST,
		sub: '',
		iat: now,
		exp: now + 3600,
		/**
		 * https://developers.google.com/identity/protocols/oauth2/service-account#jwt-auth
		 * "without OAuth" の話だが、OAuth でも 1 hour になるようだ。
		 * 1 hour より長ければエラー。短ければ、1 hour のトークンが返ってくる。
		 */
		scope,
	};
	const keyB = rsa.readKeyFromPkcs8(privateKey);
	const assertion = jwt.build(header, payload, keyB);

	const response = httpClient
		.begin()
		.formParam('grant_type', 'urn:ietf:params:oauth:grant-type:jwt-bearer')
		.formParam('assertion', assertion)
		.post(URL_TOKEN_REQUEST);
	const responseText = response.getResponseAsString();
	if (response.getStatusCode() !== 200) {
		engine.log(responseText);
		throw new Error(`Failed to get Access token. status: ${response.getStatusCode()}`);
	}
	const result = JSON.parse(response.getResponseAsString());
	if (result.access_token === undefined) {
		engine.log(responseText);
		throw new Error(`Failed to get Access token. access token not found.`);
	}
	return result;
};

/**
 * モデルの実行
 * @param region
 * @param projectId
 * @param model
 * @param maxTokens
 * @param temperature
 * @param stopSequences
 * @param message
 * @param inlineImages
 * @returns {String} answer
 */
const invokeModel = (
	auth,
	region,
	projectId,
	model,
	maxTokens,
	temperature,
	stopSequences,
	message,
	inlineImages
) => {
	const URL = `https://${region}-aiplatform.googleapis.com/v1/projects/${projectId}/locations/${region}/publishers/google/models/${model}:streamGenerateContent`;

	const generation_config = {};
	if (maxTokens !== null) {
		generation_config.maxOutputTokens = maxTokens;
	}
	if (temperature !== null) {
		generation_config.temperature = temperature;
	}
	generation_config.stopSequences = stopSequences;
	const payload = {
		contents: {
			role: 'user',
			parts: [
				{
					text: message,
				},
			],
		},
		safety_settings: {
			category: 'HARM_CATEGORY_SEXUALLY_EXPLICIT',
			threshold: 'BLOCK_LOW_AND_ABOVE',
		},
		generation_config,
	};
	inlineImages.forEach((inlineImage) => {
		payload.contents.parts.push({
			inlineData: inlineImage,
		});
	});

	const response = httpClient
		.begin()
		.oauth2JwtBearer(auth, () => getAccessToken(auth))
		.body(JSON.stringify(payload), 'application/json')
		.post(URL);

	const status = response.getStatusCode();
	const respTxt = response.getResponseAsString();
	if (status !== 200) {
		engine.log(respTxt);
		throw new Error(`Failed to invoke model. status: ${status}`);
	}
	const json = JSON.parse(respTxt);
	let answers = [];

	for (const { candidates, usageMetadata } of json) {
		if (candidates[0].content === undefined) {
			engine.log('No content in the candidate.');
		} else {
			answers.push(candidates[0].content.parts[0].text);
		}
		const finishReason = candidates[0].finishReason;
		if (finishReason !== undefined) {
			engine.log(`Finish Reason: ${finishReason}`);
		}
		if (usageMetadata !== undefined) {
			if (usageMetadata.promptTokenCount !== undefined) {
				engine.log(`Prompt Token Count: ${usageMetadata.promptTokenCount}`);
			}
			if (usageMetadata.candidatesTokenCount !== undefined) {
				engine.log(`Candidates Token Count: ${usageMetadata.candidatesTokenCount}`);
			}
		}
	}

	if (answers.length === 0 || answers.join('') === '') {
		throw new Error(`No response content generated.`);
	}

	return answers.join('');
};

/**
 * データ項目への保存
 * @param configName
 * @param data
 */
const saveData = (configName, data) => {
	const def = configs.getObject(configName);
	if (def === null) {
		return;
	}
	engine.setData(def, data);
};

]]></script>

    <icon>
        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
        RU5ErkJggg==
    </icon>

    <test><![CDATA[
const PRIVATE_KEY = `-----BEGIN PRIVATE KEY-----
MIIEvgIBADANBgkqhkiG9w0BAQEFAASCBKgwggSkAgEAAoIBAQD3Zg0KVn2jff8t
NHk7p8uWEvsaxA59CkGi1v81kyVsnd+yxm23nWIKhGplhy0hK7dnBP3OMB0YCfvo
yXqryQMJb96xMyPkW+n9a1uh3wOibpPzhw/QbVzd5vgMcK9qN2M5oB1iYLEUvlGq
ogQ8r1gYUlt/Of0oIYKIwe9HiQXUTNxnNyW+wrURNkDio4QKMvAEqdG4iEzShAzE
bNLOG4YAdmKxZ+gL0646s5XRTIO7q/3haiF9BszxFul9GiugQ8rdPKxJEvQ9YMMt
cz39wVM4ZvJ8gmUrD5wwucDQXfeiP7bU9meBAQGpXcmYBFpBHI0hTEHYqM0MZ7pW
JVB9eEeFAgMBAAECggEBAK5LBCbjVjJHgu37COoBRcmd57AsrbRj9Gffpf69guEp
vD570zJHu5mDPl32xNGYteXrO0/2z5hu+D1BLJ43yF7upGociE3Kf2fdKbo5nprh
4nPwFDEXyxQ+M0S4YqynBs3DQtBbJIZjqq9W4ztJoPvJkdJpLTQHn6nvTz8LhsLQ
XN9nTWqTNQ3KSiUXPrXkV0dZ2sm2OCjQE99X9rm7araP6Y1FO2irGySPftwGnR+C
/jw1vLzeTCsI9+pZQ2A3JZMwYB5UPQPo/roWJ7tfrT/aT6h+eLpavDUd5W0Wowh/
HqzFQE2bJGE09F8w9mHaQAI+hG/Lr7BbO4sl3n5E3GUCgYEA/TZZc96Jqsom2f5g
iXtl6hX/5DrKVfHp6RzRpQ8aKNokJdTvtd25YiWHUY8h25O28Wdo9QDsKMkuCnlz
EOV3/624iiTGzuVCpB2/LInO4uL5mqYtBVHVDwR41WCOM2RbX5HyB8NqpycIHSO5
gZtb48OSJnGZbHEn1BkoaoywzwcCgYEA+h9Q/Bz/09GHfMNUfsjp4cQ67IX1iHqA
noPqnD8KY1UA2+KR3SBa04zk4KQkilNN5wb1r4XLvFnIWjEEicCQqsw2aEnJwGBI
6Tvd6KWw4xON2SqPlgPH75AOUQwbrsF0Gbee3OktMdOPsG86cTES7XwCOj1syN9d
kxyEMbIbRhMCgYAA8Vbb65QvopkKbrwFRwRWHsbZHq7qKwBn8ceGCcxbIpTH30cV
MkIib2lVkGbb3mzr8Sqe3uYCMN2PBGy9P113AjqRqRlkY84ftkyj6c9vYND1FnFM
d8WHTMj2YmmlH1aHwI9aIAwhmy+YjC2AogdxjaTZp8qecL1pOL7BxsxRuQKBgQCJ
qkjhqnhoNk/zLHNKIP0RhPbFjemZR4uZM5QikVP/Xh7N54NPCOrUuxySQ+XUuIsN
GDiLdgGv1l6+vXH4+6LkTue3OL2xg409yfSWgvO719xf5dwHvmcCBPDMTPTDl7h2
Gyl1/2UfoojYnC+3c0Iuse1r7rj8SmxvduePjq8SPwKBgACswSW/FWGFyqfhXvIv
QWSZF/yiIsywjJgiTsRp92Cr98QDQNC0c8SCQWew3T1r/CHX3EDqjf3djx5qISpi
ESFz5+HMVWL2lMD5KqLxIdHZNe4fbPyW779yMNdyd0rlgOS1kM3WrYdV9tgjc1VI
lweR14IODzhshANib/N8F47e
-----END PRIVATE KEY-----`;

const CERTIFICATE = `-----BEGIN CERTIFICATE-----
MIIDbzCCAlegAwIBAgIUPV0u0uVd+8UHrS6NRz/xVad9oRUwDQYJKoZIhvcNAQEL
BQAwRzELMAkGA1UEBhMCSlAxDjAMBgNVBAgMBUt5b3RvMRIwEAYDVQQKDAlRdWVz
dGV0cmExFDASBgNVBAsMC0RldmVsb3BtZW50MB4XDTI0MDExODA4MDYxMVoXDTI0
MDIxNzA4MDYxMVowRzELMAkGA1UEBhMCSlAxDjAMBgNVBAgMBUt5b3RvMRIwEAYD
VQQKDAlRdWVzdGV0cmExFDASBgNVBAsMC0RldmVsb3BtZW50MIIBIjANBgkqhkiG
9w0BAQEFAAOCAQ8AMIIBCgKCAQEA92YNClZ9o33/LTR5O6fLlhL7GsQOfQpBotb/
NZMlbJ3fssZtt51iCoRqZYctISu3ZwT9zjAdGAn76Ml6q8kDCW/esTMj5Fvp/Wtb
od8Dom6T84cP0G1c3eb4DHCvajdjOaAdYmCxFL5RqqIEPK9YGFJbfzn9KCGCiMHv
R4kF1EzcZzclvsK1ETZA4qOECjLwBKnRuIhM0oQMxGzSzhuGAHZisWfoC9OuOrOV
0UyDu6v94WohfQbM8RbpfRoroEPK3TysSRL0PWDDLXM9/cFTOGbyfIJlKw+cMLnA
0F33oj+21PZngQEBqV3JmARaQRyNIUxB2KjNDGe6ViVQfXhHhQIDAQABo1MwUTAd
BgNVHQ4EFgQU+XQRQgTm3ffYqLngkqr03TFcbvcwHwYDVR0jBBgwFoAU+XQRQgTm
3ffYqLngkqr03TFcbvcwDwYDVR0TAQH/BAUwAwEB/zANBgkqhkiG9w0BAQsFAAOC
AQEAOnZodDZ4tqjkofJbIcuXczFGPta6geFl/my3H2Ubf2PJNEkDxklgml7uMych
vs/lWi0p7YQII52lbMytADKeG/YLOBVQMp5e3WDI3D+630b3T20AwZcXW3KuAYn1
sQuSh7RijcOKDoTMQNUCMjgBbzr5Z4eq0HYl/Uivmkdh5YH0nU2+LbU/G1RDDodh
Q+J3TyL+Ms9ba5V8/7gs7Vaz9uuRBdYpq/MP+Iyb78/yIGOxk9Qj0fXdc+W69XGP
rqpI6o1cfaFHC3zkRdyZA9Tvh3yE3XID9J5xRZRmUuCzUR4YkJQx436E7EzVohq7
lc8AgiU0Y7Qg6Nm8cXQ7LgMfKw==
-----END CERTIFICATE-----`;

/**
 * 設定の準備
 * @param scome スコープ
 * @param privateKeyId 秘密鍵 ID
 * @param privateKey 秘密鍵
 * @param serviceAccount サービスアカウント
 * @param region リージョンコード
 * @param projectId プロジェクト ID
 * @param model モデル
 * @param maxTokens トークン数の最大値
 * @param temperature 温度
 * @param stopSequences 停止シーケンス
 * @param message ユーザーのメッセージ
 * @returns {ProcessDataDefinitionView} answerDef
 */
const prepareConfigs = (
	scope,
	privateKeyId,
	privateKey,
	serviceAccount,
	region,
	projectId,
	model,
	maxTokens,
	temperature,
	stopSequences,
	message
) => {
	// 認証設定を作成し、指定
	const jwtAuth = httpClient.createAuthSettingOAuth2JwtBearer(
		'JWT',
		scope,
		'',
		'',
		privateKeyId,
		privateKey,
		serviceAccount,
		''
	);
	configs.putObject('conf_Auth', jwtAuth);

	configs.put('conf_Region', region);
	configs.put('conf_ProjectId', projectId);
	configs.put('conf_Model', model);
	configs.put('conf_MaxTokens', maxTokens);
	configs.put('conf_Temperature', temperature);
	configs.put('conf_StopSequences', stopSequences);
	configs.put('conf_Message1', message);

	// 回答を保存するデータ項目を作成し、指定
	const answerDef = engine.createDataDefinition('回答', 1, 'q_response', 'STRING_TEXTAREA');
	configs.putObject('conf_Answer1', answerDef);
	engine.setData(answerDef, '事前文字列');
	return answerDef;
};

/**
 * 異常系のテスト
 * @param errorMsg
 */
const assertError = (errorMsg) => {
	let failed = false;
	try {
		main();
	} catch (e) {
		failed = true;
		expect(e.message).toEqual(errorMsg);
	}
	if (!failed) {
		fail('No error was thrown.');
	}
};

/**
 * リージョンコードの形式が不正 - ハイフンを含まない
 */
test('Region Code is invalid - no hyphens', () => {
	const privateKeyId = 'key-12345';
	const region = 'invalidregioncode';
	const projectId = 'project-67890';
	const model = 'gemini-2.0-flash';
	const serviceAccount = 'service@questetra.com';
	const message = 'Hi. How are you?';
	prepareConfigs(
		SCOPE,
		privateKeyId,
		PRIVATE_KEY,
		serviceAccount,
		region,
		projectId,
		model,
		'',
		'',
		'',
		message
	);

	assertError('Region Code is invalid.');
});

/**
 * リージョンコードの形式が不正 - ハイフンの間の文字列が長すぎる
 */
test('Region Code is invalid - too many characters', () => {
	const privateKeyId = 'key-12345';
	const serviceAccount = 'service@questetra.com';
	const region = 'northamerica-northamericatoooomany1';
	const projectId = 'project-67890';
	const model = 'gemini-2.0-flash-lite';
	const message = 'Hi. How are you?';
	prepareConfigs(
		SCOPE,
		privateKeyId,
		PRIVATE_KEY,
		serviceAccount,
		region,
		projectId,
		model,
		'',
		'',
		'',
		message
	);

	assertError('Region Code is invalid.');
});

/**
 * モデルの指定が不正 - 英数字、ピリオド、ハイフン以外の文字を含む
 */
test('Invalid model', () => {
	const privateKeyId = 'key-12345';
	const serviceAccount = 'service@questetra.com';
	const region = 'asia-northeast1';
	const projectId = 'project-67890';
	const model = '不正なモデル';
	const message = 'Hi. How are you?';
	prepareConfigs(
		SCOPE,
		privateKeyId,
		PRIVATE_KEY,
		serviceAccount,
		region,
		projectId,
		model,
		'',
		'',
		'',
		message
	);

	assertError('Model includes an invalid character.');
});

/**
 * トークン数の最大値が正の整数でない - 数字でない文字を含む
 */
test('Maximum number of tokens must be a positive integer - includes a non-numeric character', () => {
	const privateKeyId = 'key-12345';
	const serviceAccount = 'service@questetra.com';
	const region = 'asia-northeast1';
	const projectId = 'project-67890';
	const model = 'gemini-2.0-flash';
	const maxTokens = '1.1';
	const message = 'Hi. How are you?';
	prepareConfigs(
		SCOPE,
		privateKeyId,
		PRIVATE_KEY,
		serviceAccount,
		region,
		projectId,
		model,
		maxTokens,
		'',
		'',
		message
	);

	assertError('Maximum number of tokens must be a positive integer.');
});

/**
 * トークン数の最大値が正の整数でない - ゼロ
 */
test('Maximum number of tokens must be a positive integer - 0', () => {
	const privateKeyId = 'key-12345';
	const serviceAccount = 'service@questetra.com';
	const region = 'asia-northeast1';
	const projectId = 'project-67890';
	const model = 'gemini-2.0-flash-lite';
	const maxTokens = '0';
	const message = 'Hi. How are you?';
	prepareConfigs(
		SCOPE,
		privateKeyId,
		PRIVATE_KEY,
		serviceAccount,
		region,
		projectId,
		model,
		maxTokens,
		'',
		'',
		message
	);

	assertError('Maximum number of tokens must be a positive integer.');
});

/**
 * 温度が不正 - 数字、小数点でない文字を含む
 */
test('Invalid temperature - includes a non-numeric character', () => {
	const privateKeyId = 'key-12345';
	const serviceAccount = 'service@questetra.com';
	const region = 'asia-northeast1';
	const projectId = 'project-67890';
	const model = 'gemini-2.0-flash';
	const maxTokens = '100';
	const temperature = '-0.1';
	const message = 'Hi. How are you?';
	prepareConfigs(
		SCOPE,
		privateKeyId,
		PRIVATE_KEY,
		serviceAccount,
		region,
		projectId,
		model,
		maxTokens,
		temperature,
		'',
		message
	);

	assertError('Temperature must be a number from 0 to 2.');
});

/**
 * 温度が不正 - 2 を超える
 */
test('Invalid temperature - bigger than 2', () => {
	const privateKeyId = 'key-12345';
	const serviceAccount = 'service@questetra.com';
	const region = 'asia-northeast1';
	const projectId = 'project-67890';
	const model = 'gemini-2.0-flash-lite';
	const maxTokens = '100';
	const temperature = '2.1';
	const message = 'Hi. How are you?';
	prepareConfigs(
		SCOPE,
		privateKeyId,
		PRIVATE_KEY,
		serviceAccount,
		region,
		projectId,
		model,
		maxTokens,
		temperature,
		'',
		message
	);

	assertError('Temperature must be a number from 0 to 2.');
});

/**
 * 停止シークエンスの数が多すぎる
 */
test('Too many stop sequences', () => {
	const privateKeyId = 'key-12345';
	const serviceAccount = 'service@questetra.com';
	const region = 'asia-northeast1';
	const projectId = 'project-67890';
	const model = 'gemini-2.0-flash';
	const maxTokens = '100';
	const temperature = '1.0';
	const stopSequences = 'a\n'.repeat(6);
	const message = 'Hi. How are you?';
	prepareConfigs(
		SCOPE,
		privateKeyId,
		PRIVATE_KEY,
		serviceAccount,
		region,
		projectId,
		model,
		maxTokens,
		temperature,
		stopSequences,
		message
	);

	assertError('Too many stop sequences. The maximum number is 5.');
});

/**
 * メッセージが空
 */
test('Message is empty', () => {
	const privateKeyId = 'key-12345';
	const serviceAccount = 'service@questetra.com';
	const region = 'asia-northeast1';
	const projectId = 'project-67890';
	const model = 'gemini-2.0-flash';
	prepareConfigs(
		SCOPE,
		privateKeyId,
		PRIVATE_KEY,
		serviceAccount,
		region,
		projectId,
		model,
		'',
		'',
		'',
		''
	);

	assertError('User Message is empty.');
});

/**
 * スコープが空
 */
test('Scope is empty', () => {
	const scope = '';
	const privateKeyId = 'key-12345';
	const serviceAccount = 'service@questetra.com';
	const region = 'asia-northeast1';
	const projectId = 'project-67890';
	const model = 'gemini-2.0-flash-lite';
	const message = 'Hi. How are you?';
	prepareConfigs(
		scope,
		privateKeyId,
		PRIVATE_KEY,
		serviceAccount,
		region,
		projectId,
		model,
		'',
		'',
		'',
		message
	);

	assertError(`Scope ${SCOPE} must be included in the scope.`);
});

const ANOTHER_SCOPE = 'https://www.googleapis.com/auth/drive.readonly';

/**
 * スコープに必須スコープを含まない
 */
test('Required scope is missing', () => {
	const privateKeyId = 'key-12345';
	const serviceAccount = 'service@questetra.com';
	const region = 'asia-northeast1';
	const projectId = 'project-67890';
	const model = 'gemini-2.0-flash';
	const message = 'Hi. How are you?';
	prepareConfigs(
		ANOTHER_SCOPE,
		privateKeyId,
		PRIVATE_KEY,
		serviceAccount,
		region,
		projectId,
		model,
		'',
		'',
		'',
		message
	);

	assertError(`Scope ${SCOPE} must be included in the scope.`);
});

/**
 * 秘密鍵 ID が空
 */
test('Private Key ID is empty', () => {
	const privateKeyId = '';
	const serviceAccount = 'service@questetra.com';
	const region = 'asia-northeast1';
	const projectId = 'project-67890';
	const model = 'gemini-2.0-flash-lite';
	const message = 'Hi. How are you?';
	prepareConfigs(
		SCOPE,
		privateKeyId,
		PRIVATE_KEY,
		serviceAccount,
		region,
		projectId,
		model,
		'',
		'',
		'',
		message
	);

	assertError('Private Key ID is required.');
});

/**
 * カスタム秘密情報1 に設定されている
 * サービスアカウントが空。
 */
test('Service Account is empty', () => {
	const privateKeyId = 'key-12345';
	const serviceAccount = '';
	const region = 'asia-northeast1';
	const projectId = 'project-67890';
	const model = 'gemini-2.0-flash';
	const message = 'Hi. How are you?';
	prepareConfigs(
		SCOPE,
		privateKeyId,
		PRIVATE_KEY,
		serviceAccount,
		region,
		projectId,
		model,
		'',
		'',
		'',
		message
	);

	assertError('Service Account must be set to Custom Secret 1.');
});

/**
 * 指定サイズのファイルを作成
 * @param name
 * @param contentType
 * @param size
 * @return qfile
 */
const createQfile = (name, contentType, size) => {
	let text = '';
	if (size >= 4000) {
		text = 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa'.repeat(100); // 40 * 100 = 4000
	}
	while (text.length < size) {
		if (text.length !== 0 && text.length * 2 <= size) {
			text += text;
		} else if (text.length + 1000 <= size) {
			text += 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa'.repeat(25); // 40 * 25 = 1000
		} else {
			text += 'a';
		}
	}
	return engine.createQfile(name, contentType, text);
};

/**
 * 画像・動画を添付
 * @param {Array<Qfile>} images
 */
const attachImages = (images) => {
	const imagesDef = engine.createDataDefinition('添付画像／動画', 2, 'q_images', 'FILE');
	engine.setData(imagesDef, images);
	configs.putObject('conf_Images1', imagesDef);
};

/**
 * 添付ファイルのサイズが大きすぎる
 */
test('Attached file is too large', () => {
	const privateKeyId = 'key-12345';
	const serviceAccount = 'service@example.com';
	const region = 'asia-northeast1';
	const projectId = 'project-67890';
	const model = 'gemini-2.0-flash-lite';
	const message = 'Please describe each image attached.';
	prepareConfigs(
		SCOPE,
		privateKeyId,
		PRIVATE_KEY,
		serviceAccount,
		region,
		projectId,
		model,
		'',
		'',
		'',
		message
	);

	// 添付ファイルを指定
	const image1 = createQfile('画像1.png', 'image/png', 100);
	const image2 = createQfile('画像2.jpg', 'image/jpeg', MAX_IMAGE_SIZE + 1);
	attachImages([image1, image2]);

	assertError(
		`Attached file "画像2.jpg" is too large. Each file must be less than ${MAX_IMAGE_SIZE} bytes.`
	);
});

/**
 * 添付ファイルに画像/動画/音声でないファイルを含む
 */
test('Attached file is neither an image, video nor audio', () => {
	const privateKeyId = 'key-12345';
	const serviceAccount = 'service@example.com';
	const region = 'asia-northeast1';
	const projectId = 'project-67890';
	const model = 'gemini-2.0-flash';
	const message = 'Please describe each image attached.';
	prepareConfigs(
		SCOPE,
		privateKeyId,
		PRIVATE_KEY,
		serviceAccount,
		region,
		projectId,
		model,
		'',
		'',
		'',
		message
	);

	// 添付ファイルを指定
	const video = createQfile('動画', 'video/mp4', 200);
	const text = createQfile('テキストファイル', 'text/plain', 100);
	attachImages([video, text]);

	assertError('Attached file "テキストファイル" is neither an image, video, audio, nor PDF.');
});

/**
 * トークン取得リクエストのテスト
 * @param {Object} request
 * @param request.url
 * @param request.method
 * @param request.contentType
 * @param request.body
 * @param {String} scope
 * @param {String} serviceAccount
 */
const assertTokenRequest = ({ url, method, contentType, body }, scope, serviceAccount) => {
	expect(url).toEqual(URL_TOKEN_REQUEST);
	expect(method).toEqual('POST');
	expect(contentType).startsWith('application/x-www-form-urlencoded');
	const query = `grant_type=${encodeURIComponent(
		'urn:ietf:params:oauth:grant-type:jwt-bearer'
	)}&assertion=`;
	expect(body).startsWith(query);
	const assertion = decodeURIComponent(body.substring(query.length));

	const publicKey = rsa.readKeyFromX509(CERTIFICATE);
	expect(jwt.verify(assertion, publicKey)).toEqual(true);

	const payloadJson = base64.decodeFromUrlSafeString(assertion.split('.')[1]);
	const payload = JSON.parse(payloadJson);
	expect(payload.iss).toEqual(serviceAccount);
	expect(payload.aud).toEqual(URL_TOKEN_REQUEST);
	expect(payload.scope).toEqual(scope);
};

/**
 * API リクエストのテスト
 * @param {Object} request
 * @param request.url
 * @param request.method
 * @param request.contentType
 * @param request.headers
 * @param request.body
 * @param {String} token
 * @param {String} region
 * @param {String} projectId
 * @param {String} model
 * @param {Number} maxTokens
 * @param {Number} temperature
 * @param {Array<String>} stopSequences
 * @param {String} message
 * @param {Array<Qfile>} images
 */
const assertRequest = (
	{ url, method, contentType, headers, body },
	token,
	region,
	projectId,
	model,
	maxTokens,
	temperature,
	stopSequences,
	message,
	images = []
) => {
	expect(url).toEqual(
		`https://${region}-aiplatform.googleapis.com/v1/projects/${projectId}/locations/${region}/publishers/google/models/${model}:streamGenerateContent`
	);
	expect(method).toEqual('POST');
	expect(contentType).toEqual('application/json');
	expect(headers.Authorization).toEqual(`Bearer ${token}`);
	const bodyObj = JSON.parse(body);
	expect(bodyObj.contents.parts[0].text).toEqual(message);
	if (maxTokens !== null) {
		expect(bodyObj.generation_config.maxOutputTokens).toEqual(maxTokens);
	} else {
		expect(bodyObj.generation_config.maxOutputTokens).toEqual(undefined);
	}
	if (temperature !== null) {
		expect(bodyObj.generation_config.temperature).toEqual(temperature);
	} else {
		expect(bodyObj.generation_config.temperature).toEqual(undefined);
	}
	expect(bodyObj.generation_config.stopSequences).toEqual(stopSequences);
	images.forEach((image, i) => {
		expect(bodyObj.contents.parts[i + 1].inlineData.mimeType).toEqual(image.getContentType());
		expect(bodyObj.contents.parts[i + 1].inlineData.data).toEqual(
			base64.encodeToString(fileRepository.readFile(image))
		);
	});
};

/**
 * API のレスポンスボディを作成
 * @param {String} answers
 * @returns {String} response
 */
const createResponse = (...answers) => {
	const responseObj = answers.map((answer) => ({
		candidates: [
			{
				content: {
					parts: [
						{
							text: answer,
						},
					],
				},
				finishReason: 'FINISH_REASON_STOP ',
				safetyRatings: [],
				citationMetadata: {
					citations: [],
				},
			},
		],
	}));
	return JSON.stringify(responseObj);
};

/**
 * API リクエストでエラー
 */
test('Fail to request', () => {
	const privateKeyId = 'key-12345';
	const serviceAccount = 'service@questetra.com';
	const region = 'asia-northeast1';
	const projectId = 'project-67890';
	const model = 'gemini-2.0-flash-lite';
	const message = 'Hi. How are you?';
	prepareConfigs(
		SCOPE,
		privateKeyId,
		PRIVATE_KEY,
		serviceAccount,
		region,
		projectId,
		model,
		'',
		'',
		'',
		message
	);

	const token = 'token';
	let reqCount = 0;
	httpClient.setRequestHandler((request) => {
		if (reqCount++ === 0) {
			assertTokenRequest(request, SCOPE, serviceAccount);
			return httpClient.createHttpResponse(
				200,
				'application/json',
				JSON.stringify({
					access_token: token,
				})
			);
		}
		assertRequest(request, token, region, projectId, model, null, null, [], message);
		return httpClient.createHttpResponse(400, 'application/json', '{}');
	});
	assertError('Failed to invoke model. status: 400');
});

/**
 * API リクエストが 200 レスポンスを返すが、トークン切れで回答が空の場合
 * text フィールドを持つ content がない場合
 */
test('No response content generated - no content with text field', () => {
	const privateKeyId = 'key-12345';
	const serviceAccount = 'service@questetra.com';
	const region = 'asia-northeast1';
	const projectId = 'project-67890';
	const model = 'gemini-2.0-flash';
	const maxTokens = '100';
	const temperature = '1';
	const message = 'Hi. How are you?';
	prepareConfigs(
		SCOPE,
		privateKeyId,
		PRIVATE_KEY,
		serviceAccount,
		region,
		projectId,
		model,
		maxTokens,
		temperature,
		'',
		message
	);

	const token = 'token';
	let reqCount = 0;
	httpClient.setRequestHandler((request) => {
		if (reqCount++ === 0) {
			assertTokenRequest(request, SCOPE, serviceAccount);
			return httpClient.createHttpResponse(
				200,
				'application/json',
				JSON.stringify({
					access_token: token,
				})
			);
		}
		assertRequest(request, token, region, projectId, model, 100, 1, [], message);

		const responseObj = [
			{
				candidates: [
					{
						finishReason: 'MAX_TOKENS',
						safetyRatings: [],
						citationMetadata: {
							citations: [],
						},
					},
				],
			},
		];

		return httpClient.createHttpResponse(200, 'application/json', JSON.stringify(responseObj));
	});

	assertError('No response content generated.');
});

/**
 * API リクエストが 200 レスポンスを返すが、トークン切れで回答が空の場合
 * text フィールドを持つ content が undefined の場合
 */
test('No response content generated - content is undefined', () => {
	const privateKeyId = 'key-12345';
	const serviceAccount = 'service@questetra.com';
	const region = 'asia-northeast1';
	const projectId = 'project-67890';
	const model = 'gemini-2.0-flash';
	const maxTokens = '100';
	const temperature = '1';
	const message = 'Hi. How are you?';
	prepareConfigs(
		SCOPE,
		privateKeyId,
		PRIVATE_KEY,
		serviceAccount,
		region,
		projectId,
		model,
		maxTokens,
		temperature,
		'',
		message
	);

	const token = 'token';
	let reqCount = 0;
	httpClient.setRequestHandler((request) => {
		if (reqCount++ === 0) {
			assertTokenRequest(request, SCOPE, serviceAccount);
			return httpClient.createHttpResponse(
				200,
				'application/json',
				JSON.stringify({
					access_token: token,
				})
			);
		}
		assertRequest(request, token, region, projectId, model, 100, 1, [], message);

		const responseObj = [
			{
				candidates: [
					{
						content: undefined,
						finishReason: 'FINISH_REASON_MAX_TOKENS',
						safetyRatings: [],
						citationMetadata: {
							citations: [],
						},
					},
				],
			},
		];

		return httpClient.createHttpResponse(200, 'application/json', JSON.stringify(responseObj));
	});

	assertError('No response content generated.');
});

/**
 * API リクエストが 200 レスポンスを返すが、トークン切れで回答が空の場合
 * text フィールドの値が空の場合
 */
test('No response content generated - text field is blank', () => {
	const privateKeyId = 'key-12345';
	const serviceAccount = 'service@questetra.com';
	const region = 'asia-northeast1';
	const projectId = 'project-67890';
	const model = 'gemini-2.0-flash-lite';
	const maxTokens = '100';
	const temperature = '1';
	const message = 'Hi. How are you?';
	prepareConfigs(
		SCOPE,
		privateKeyId,
		PRIVATE_KEY,
		serviceAccount,
		region,
		projectId,
		model,
		maxTokens,
		temperature,
		'',
		message
	);

	const token = 'token';
	let reqCount = 0;
	httpClient.setRequestHandler((request) => {
		if (reqCount++ === 0) {
			assertTokenRequest(request, SCOPE, serviceAccount);
			return httpClient.createHttpResponse(
				200,
				'application/json',
				JSON.stringify({
					access_token: token,
				})
			);
		}
		assertRequest(request, token, region, projectId, model, 100, 1, [], message);

		const responseObj = [
			{
				candidates: [
					{
						content: {
							parts: [
								{
									text: '',
								},
							],
						},
						finishReason: 'FINISH_REASON_MAX_TOKENS',
						safetyRatings: [],
						citationMetadata: {
							citations: [],
						},
					},
				],
			},
		];

		return httpClient.createHttpResponse(200, 'application/json', JSON.stringify(responseObj));
	});

	assertError('No response content generated.');
});

/**
 * 成功
 * gemini-1.0-pro
 * 必須スコープのみ
 * 最大トークン数、温度、停止シーケンスを指定する
 * 添付ファイルなし（データ項目の指定なし）
 */
test('Success - with max tokens, no attached files', () => {
	const privateKeyId = 'key-67890';
	const region = 'asia-northeast1';
	const projectId = 'project-12345';
	const serviceAccount = 'service@example.com';
	const model = 'gemini-2.0-flash';
	const maxTokens = '2048';
	const temperature = '0.5';
	const stopSequences = 'a\nb\nc\nd\ne\n';
	const message = 'Hi. How are you?';
	const answerDef = prepareConfigs(
		SCOPE,
		privateKeyId,
		PRIVATE_KEY,
		serviceAccount,
		region,
		projectId,
		model,
		maxTokens,
		temperature,
		stopSequences,
		message
	);

	const token = 'token-12345';
	let reqCount = 0;
	httpClient.setRequestHandler((request) => {
		if (reqCount++ === 0) {
			assertTokenRequest(request, SCOPE, serviceAccount);
			return httpClient.createHttpResponse(
				200,
				'application/json',
				JSON.stringify({
					access_token: token,
				})
			);
		}
		assertRequest(
			request,
			token,
			region,
			projectId,
			model,
			2048,
			0.5,
			['a', 'b', 'c', 'd', 'e'],
			message
		);
		return httpClient.createHttpResponse(
			200,
			'application/json',
			createResponse('Fine, thanks. ', 'How about you?')
		);
	});

	expect(main()).toEqual(undefined);
	expect(engine.findData(answerDef)).toEqual('Fine, thanks. How about you?');
});

/**
 * 成功
 * gemini-1.5-pro
 * 必須スコープ以外も指定
 * 最大トークン数、温度を指定
 * 停止シーケンス指定なし
 * 添付ファイルなし（データ項目は指定しているが、添付ファイルなし）
 */
test('Success - withmax tokens, empty attached files', () => {
	const scope = `${SCOPE} ${ANOTHER_SCOPE}`;
	const privateKeyId = 'key-12345';
	const region = 'asia-southeast1';
	const projectId = 'project-67890';
	const serviceAccount = 'service@questetra.com';
	const model = 'gemini-2.0-flash-lite';
	const maxTokens = '1024';
	const temperature = '0';
	const message = 'こんにちは。';
	const answerDef = prepareConfigs(
		scope,
		privateKeyId,
		PRIVATE_KEY,
		serviceAccount,
		region,
		projectId,
		model,
		maxTokens,
		temperature,
		'',
		message
	);
	attachImages([]);

	const token = 'token-67890';
	let reqCount = 0;
	httpClient.setRequestHandler((request) => {
		if (reqCount++ === 0) {
			assertTokenRequest(request, scope, serviceAccount);
			return httpClient.createHttpResponse(
				200,
				'application/json',
				JSON.stringify({
					access_token: token,
				})
			);
		}
		assertRequest(request, token, region, projectId, model, 1024, 0, [], message);
		return httpClient.createHttpResponse(
			200,
			'application/json',
			createResponse('こんにちは。元気ですか？')
		);
	});

	expect(main()).toEqual(undefined);
	expect(engine.findData(answerDef)).toEqual('こんにちは。元気ですか？');
});

/**
 * 成功
 * gemini-1.5-flash
 * 必須スコープ以外も指定
 * 最大トークン数、温度、停止シーケンスを指定しない
 * 画像ファイルを複数添付
 */
test('Success - with default tokens, with a number of attached images', () => {
	const scope = `${ANOTHER_SCOPE} ${SCOPE}`;
	const privateKeyId = 'key-12345';
	const region = 'asia-southeast1';
	const projectId = 'project-67890';
	const serviceAccount = 'service@questetra.com';
	const model = 'gemini-2.0-flash';
	const message = 'Please describe each image attached.';
	const answerDef = prepareConfigs(
		scope,
		privateKeyId,
		PRIVATE_KEY,
		serviceAccount,
		region,
		projectId,
		model,
		'',
		'',
		'',
		message
	);

	// 添付ファイルを指定
	const images = [];
	for (let i = 0; i < 10; i++) {
		images.push(createQfile(`画像${i}.png`, 'image/png', 100));
	}
	attachImages(images);

	const token = 'token-98765';
	let reqCount = 0;
	httpClient.setRequestHandler((request) => {
		if (reqCount++ === 0) {
			assertTokenRequest(request, scope, serviceAccount);
			return httpClient.createHttpResponse(
				200,
				'application/json',
				JSON.stringify({
					access_token: token,
				})
			);
		}
		assertRequest(request, token, region, projectId, model, null, null, [], message, images);
		return httpClient.createHttpResponse(
			200,
			'application/json',
			createResponse('The 1st image shows a cat. The 2nd image shows a dog.')
		);
	});

	expect(main()).toEqual(undefined);
	expect(engine.findData(answerDef)).toEqual(
		'The 1st image shows a cat. The 2nd image shows a dog.'
	);
});

/**
 * 成功
 * gemini-1.5-pro
 * 必須スコープのみ
 * 最大トークン数、停止シーケンスを指定しない
 * 温度を指定
 * 動画ファイルを 1 つ添付
 */
test('Success - with default tokens, with an attached video', () => {
	const privateKeyId = 'key-12345';
	const region = 'asia-southeast1';
	const projectId = 'project-67890';
	const serviceAccount = 'service@questetra.com';
	const model = 'gemini-2.0-flash-lite';
	const temperature = '1.00';
	const message = 'Please describe the video attached.';
	const answerDef = prepareConfigs(
		SCOPE,
		privateKeyId,
		PRIVATE_KEY,
		serviceAccount,
		region,
		projectId,
		model,
		'',
		temperature,
		'',
		message
	);

	// 添付ファイルを指定
	const video = createQfile('動画.mp4', 'video/mp4', MAX_IMAGE_SIZE);
	attachImages([video]);

	const token = 'token-98765';
	let reqCount = 0;
	httpClient.setRequestHandler((request) => {
		if (reqCount++ === 0) {
			assertTokenRequest(request, SCOPE, serviceAccount);
			return httpClient.createHttpResponse(
				200,
				'application/json',
				JSON.stringify({
					access_token: token,
				})
			);
		}
		assertRequest(request, token, region, projectId, model, null, 1, [], message, [video]);
		return httpClient.createHttpResponse(
			200,
			'application/json',
			createResponse('The video shows a sleeping cat.')
		);
	});

	expect(main()).toEqual(undefined);
	expect(engine.findData(answerDef)).toEqual('The video shows a sleeping cat.');
});

/**
 * 成功
 * gemini-1.5-pro
 * 必須スコープのみ
 * 最大トークン数、停止シーケンスを指定しない
 * 温度を指定（最大値の 2）
 * 動画ファイル、音声ファイルを添付
 */
test('Success - with default tokens, with a video and an audio', () => {
	const privateKeyId = 'key-12345';
	const region = 'asia-southeast1';
	const projectId = 'project-67890';
	const serviceAccount = 'service@questetra.com';
	const model = 'gemini-2.0-flash';
	const temperature = '2.00';
	const message = 'Please describe the video attached.';
	const answerDef = prepareConfigs(
		SCOPE,
		privateKeyId,
		PRIVATE_KEY,
		serviceAccount,
		region,
		projectId,
		model,
		'',
		temperature,
		'',
		message
	);

	// 添付ファイルを指定
	const video = createQfile('動画.mov', 'video/mov', 500);
	const audio = createQfile('音声.mp3', 'audio/mp3', 500);
	attachImages([video, audio]);

	const token = 'token-98765';
	let reqCount = 0;
	httpClient.setRequestHandler((request) => {
		if (reqCount++ === 0) {
			assertTokenRequest(request, SCOPE, serviceAccount);
			return httpClient.createHttpResponse(
				200,
				'application/json',
				JSON.stringify({
					access_token: token,
				})
			);
		}
		assertRequest(request, token, region, projectId, model, null, 2, [], message, [video]);
		return httpClient.createHttpResponse(
			200,
			'application/json',
			createResponse(
				'The video shows a sleeping cat and the audio sounds like a cheering voice.'
			)
		);
	});

	expect(main()).toEqual(undefined);
	expect(engine.findData(answerDef)).toEqual(
		'The video shows a sleeping cat and the audio sounds like a cheering voice.'
	);
});

/**
 * 成功
 * gemini-1.5-pro
 * レスポンスに content プロパティが空の候補を含む
 */
test('Success - includes candidate without content', () => {
	const privateKeyId = 'key-12345';
	const region = 'asia-southeast1';
	const projectId = 'project-67890';
	const serviceAccount = 'service@questetra.com';
	const model = 'gemini-2.0-flash-lite';
	const temperature = '';
	const message = 'Hi. How are you?';
	const answerDef = prepareConfigs(
		SCOPE,
		privateKeyId,
		PRIVATE_KEY,
		serviceAccount,
		region,
		projectId,
		model,
		'',
		temperature,
		'',
		message
	);

	const token = 'token-98765';
	let reqCount = 0;
	httpClient.setRequestHandler((request) => {
		if (reqCount++ === 0) {
			assertTokenRequest(request, SCOPE, serviceAccount);
			return httpClient.createHttpResponse(
				200,
				'application/json',
				JSON.stringify({
					access_token: token,
				})
			);
		}
		assertRequest(request, token, region, projectId, model, null, null, [], message);
		const responseObj = ['Hi. ', 'dummy', 'I am fine. ', 'Thank you.'].map((answer) => ({
			candidates: [
				{
					content: {
						parts: [
							{
								text: answer,
							},
						],
					},
				},
			],
		}));
		responseObj[1].candidates[0].content = undefined; // content プロパティを空に
		return httpClient.createHttpResponse(200, 'application/json', JSON.stringify(responseObj));
	});

	expect(main()).toEqual(undefined);
	expect(engine.findData(answerDef)).toEqual('Hi. I am fine. Thank you.');
});

/**
 * 成功
 * gemini-1.5-pro
 * 必須スコープのみ
 * 最大トークン数、停止シーケンスを指定しない
 * 温度を指定
 * 画像ファイル、PDF ファイルを添付
 * 回答を保存するデータ項目に、文字型 Markdown を指定
 */
test('Success - with default tokens, with a image and an PDF', () => {
	const privateKeyId = 'key-12345';
	const region = 'asia-southeast1';
	const projectId = 'project-67890';
	const serviceAccount = 'service@questetra.com';
	const model = 'gemini-2.0-flash';
	const temperature = '1.00';
	const message = 'Please describe the image and pdf attached.';
	prepareConfigs(
		SCOPE,
		privateKeyId,
		PRIVATE_KEY,
		serviceAccount,
		region,
		projectId,
		model,
		'',
		temperature,
		'',
		message
	);

	// 回答を保存するデータ項目に、文字型 Markdown を指定
	const answerDef = engine.createDataDefinition('回答', 1, 'q_answer', 'STRING_MARKDOWN');
	engine.setData(answerDef, '事前文字列');
	configs.putObject('conf_Answer1', answerDef);

	// 添付ファイルを指定
	const image = createQfile('画像.png', 'image/png', 1000);
	const pdf = createQfile('PDF.pdf', 'application/pdf', 1000);
	attachImages([image, pdf]);

	const token = 'token-98765';
	let reqCount = 0;
	httpClient.setRequestHandler((request) => {
		if (reqCount++ === 0) {
			assertTokenRequest(request, SCOPE, serviceAccount);
			return httpClient.createHttpResponse(
				200,
				'application/json',
				JSON.stringify({
					access_token: token,
				})
			);
		}
		assertRequest(request, token, region, projectId, model, null, 1, [], message, [image, pdf]);
		return httpClient.createHttpResponse(
			200,
			'application/json',
			createResponse('The PDF is a description of the image.')
		);
	});

	expect(main()).toEqual(undefined);
	expect(engine.findData(answerDef)).toEqual('The PDF is a description of the image.');
});


]]></test>
</service-task-definition>
