<?xml version="1.0" encoding="UTF-8"?>
<service-task-definition>
    <engine-type>3</engine-type>
    <addon-version>2</addon-version>
    <label>Google Vertex AI: Gemini: Chat</label>
    <label locale="ja">Google Vertex AI: Gemini: チャット</label>
    <last-modified>2024-02-13</last-modified>
    <license>(C) Questetra, Inc. (MIT License)</license>
    <summary>This item sends a message to a Gemini model on Google Vertex AI
        and stores the response in the specified data item.</summary>
    <summary locale="ja">この工程は、Google Vertex AI 上で動作する Gemini
        のモデルにメッセージを送信し、回答をデータ項目に保存します。
    </summary>
    <help-page-url>https://support.questetra.com/bpmn-icons/service-task-google-vertexai-gemini-chat/</help-page-url>
    <help-page-url locale="ja">https://support.questetra.com/ja/bpmn-icons/service-task-google-vertexai-gemini-chat/</help-page-url>
    <configs>
        <config name="conf_Auth" required="true" form-type="OAUTH2" auth-type="OAUTH2_JWT_BEARER">
            <label>C1: 認証設定</label>
            <label locale="ja">C1: Authentication Setting</label>
        </config>
        <config name="conf_Region" required="true" form-type="TEXTFIELD">
            <label>C2: Region Code</label>
            <label locale="ja">C2: リージョンコード</label>
        </config>
        <config name="conf_ProjectId" required="true" form-type="TEXTFIELD">
            <label>C3: Project ID</label>
            <label locale="ja">C3: プロジェクト ID</label>
        </config>
        <config name="conf_Model" required="true" form-type="SELECT_ITEM">
            <label>C4: Model</label>
            <label locale="ja">C4: モデル</label>
            <item value="gemini-pro">
                <label>Gemini Pro</label>
            </item>
            <item value="gemini-pro-vision">
                <label>Gemini Pro Vision</label>
            </item>
        </config>
        <config name="conf_MaxTokens" required="false" form-type="TEXTFIELD">
            <label>C5: Maximum number of tokens to consume (model default if blank)</label>
            <label locale="ja">C5: 使用するトークン数の上限（空白の場合、モデルのデフォルト値）</label>
        </config>
        <config name="conf_Message1" required="true" el-enabled="true"
                form-type="TEXTAREA">
            <label>U1: User Message</label>
            <label locale="ja">U1: ユーザメッセージ</label>
        </config>
        <config name="conf_Images1" required="false" form-type="SELECT"
                select-data-type="FILE">
            <label>I1: Images / videos to attach to user message</label>
            <label locale="ja">I1: ユーザメッセージに添付する画像／動画</label>
        </config>
        <config name="conf_Answer1" required="true" form-type="SELECT"
                select-data-type="STRING_TEXTAREA">
            <label>A1: Data item to save response</label>
            <label locale="ja">A1: 回答を保存するデータ項目</label>
        </config>
    </configs>

    <script><![CDATA[

const MAX_IMAGE_NUM = 16; // Gemini の制限。1 プロンプトにつき添付画像 16 個まで

const MAX_IMAGE_SIZE = 20971520; // Gemini の制限。1 ファイルにつき 20 MB まで

function main() {
    ////// == 工程コンフィグ・ワークフローデータの参照 / Config & Data Retrieving ==
    const auth = configs.getObject('conf_Auth');

    const region = retrieveRegion();
    const projectId = configs.get('conf_ProjectId');
    const model = configs.get('conf_Model');
    const maxTokens = retrieveMaxTokens();
    const message = configs.get('conf_Message1');
    if (message === '') {
        throw new Error('User Message is empty.');
    }
    const inlineImages = retrieveImages();

    ////// == 演算 / Calculating ==
    const answer = invokeModel(auth, region, projectId, model, maxTokens, message, inlineImages);

    ////// == ワークフローデータへの代入 / Data Updating ==
    saveData('conf_Answer1', answer);
}

/**
 * config からリージョンコードを読み出す
 * リージョンコードの形式として不正な場合はエラー
 * @return {String}
 */
function retrieveRegion() {
    const region = configs.get('conf_Region');
    // 今後リージョンが増えることも考えて、文字数には余裕をみている
    const reg = new RegExp('^[a-z]{2,20}-[a-z]{2,20}[1-9]{1,2}$');
    if (!reg.test(region)) {
        throw new Error('Region Code is invalid.');
    }
    return region;
}

/**
 * config から最大トークン数を読み出す
 * 未定義の場合、-1 を返す
 * @returns {Number}
 */
const retrieveMaxTokens = () => {
    const maxTokens = configs.get('conf_MaxTokens');
    if (maxTokens === '') {
        return -1;
    }
    const regExp = new RegExp(/^[1-9][0-9]*$/);
    if (!regExp.test(maxTokens)) {
        throw new Error('Maximum number of tokens must be a positive integer.');
    }
    return parseInt(maxTokens, 10);
};

/**
 * config から画像・動画を読み出す
 * 以下の場合はエラー
 * - 添付ファイルの総数が多すぎる場合
 * - ファイルサイズが大きすぎる場合
 * - 画像でも動画でもないファイルが添付されている場合
 * @returns {Array<Object>} インライン画像・動画オブジェクトの配列
 */
const retrieveImages = () => {
    const imagesDef = configs.getObject('conf_Images1');
    if (imagesDef === null) {
        return [];
    }
    const images = engine.findData(imagesDef);
    if (images === null) {
        return [];
    }
    if (images.size() > MAX_IMAGE_NUM) {
        throw new Error(`Too many attached files. The maximum number is ${MAX_IMAGE_NUM}.`);
    }
    const inlineImages = [];
    images.forEach(image => {
        if (image.getLength() > MAX_IMAGE_SIZE) {
            throw new Error(`Attached file "${image.getName()}" is too large. Each file must be less than ${MAX_IMAGE_SIZE} bytes.`);
        }
        const contentType = image.getContentType();
        if (!contentType.startsWith('image/') && !contentType.startsWith('video/')){
            throw new Error(`Attached file "${image.getName()}" is neither an image nor a video.`);
        }
        const inlineImage = {
            mimeType: image.getContentType(),
            data: base64.encodeToString(fileRepository.readFile(image))
        };
        inlineImages.push(inlineImage);
    });
    return inlineImages;
};

const SCOPE = 'https://www.googleapis.com/auth/cloud-platform';
const URL_TOKEN_REQUEST = 'https://oauth2.googleapis.com/token';

/**
 * @param auth HTTP 認証設定
 * @returns {any} アクセストークンを含むオブジェクト
 */
const getAccessToken = (auth) => {
    const privateKeyId = auth.getPrivateKeyId();
    const privateKey = auth.getPrivateKey();
    const serviceAccount = auth.getCustomSecret1();
    if (privateKeyId === '') {
        throw new Error('Private Key ID is required.');
    }
    if (privateKey === '') {
        throw new Error('Private Key is required.');
    }
    if (serviceAccount === '') {
        throw new Error('Service Account must be set to Custom Secret 1.');
    }
    const header = {
        "alg": "RS256",
        "typ": "at+jwt",
        "kid": privateKeyId
    };
    const now = Math.floor(Date.now() / 1000);
    const payload = {
        "iss": serviceAccount,
        "aud": URL_TOKEN_REQUEST,
        "sub": '',
        "iat": now,
        "exp": now + 3600,
        /**
         * https://developers.google.com/identity/protocols/oauth2/service-account#jwt-auth
         * "without OAuth" の話だが、OAuth でも 1 hour になるようだ。
         * 1 hour より長ければエラー。短ければ、1 hour のトークンが返ってくる。
         */
        "scope": SCOPE
    };
    const keyB = rsa.readKeyFromPkcs8(privateKey);
    const assertion = jwt.build(header, payload, keyB);

    const response = httpClient.begin()
        .formParam("grant_type", "urn:ietf:params:oauth:grant-type:jwt-bearer")
        .formParam('assertion', assertion)
        .post(URL_TOKEN_REQUEST);
    const responseText = response.getResponseAsString();
    if (response.getStatusCode() !== 200) {
        engine.log(responseText);
        throw new Error(`Failed to get Access token. status: ${response.getStatusCode()}`);
    }
    const result = JSON.parse(response.getResponseAsString());
    if (result.access_token === undefined) {
        engine.log(responseText);
        throw new Error(`Failed to get Access token. access token not found.`);
    }
    return result;
};

/**
 * モデルの実行
 * @param region
 * @param projectId
 * @param model
 * @param maxTokens
 * @param message
 * @param inlineImages
 * @returns {String} answer
 */
const invokeModel = (auth, region, projectId, model, maxTokens, message, inlineImages) => {
    const URL = `https://${region}-aiplatform.googleapis.com/v1/projects/${projectId}/locations/${region}/publishers/google/models/${model}:streamGenerateContent`;

    const generation_config = {};
    if (maxTokens > 0) {
        generation_config.maxOutputTokens = maxTokens;
    }
    const payload = {
        "contents": {
            "role": "user",
            "parts": [
                {
                    "text": message
                }
            ]
        },
        "safety_settings": {
            "category": "HARM_CATEGORY_SEXUALLY_EXPLICIT",
            "threshold": "BLOCK_LOW_AND_ABOVE"
        },
        generation_config
    };
    inlineImages.forEach(inlineImage => {
        payload.contents.parts.push({
            'inlineData': inlineImage
        });
    });

    const response = httpClient.begin()
        .oauth2JwtBearer(auth, () => getAccessToken(auth))
        .body(JSON.stringify(payload), 'application/json')
        .post(URL);

    const status = response.getStatusCode();
    const respTxt = response.getResponseAsString();
    if (status !== 200) {
        engine.log(respTxt);
        throw new Error(`Failed to invoke model. status: ${status}`);
    }
    engine.log(respTxt);
    const json = JSON.parse(respTxt);
    return json
        .map(({candidates}) => candidates[0].content.parts[0].text)
        .join('');
};

/**
 * データ項目への保存
 * @param configName
 * @param data
 */
const saveData = (configName, data) => {
    const def = configs.getObject(configName);
    if (def === null) {
        return;
    }
    engine.setData(def, data);
};
]]></script>

    <icon>
        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
        RU5ErkJggg==
    </icon>

    <test><![CDATA[
const PRIVATE_KEY = `-----BEGIN PRIVATE KEY-----
MIIEvgIBADANBgkqhkiG9w0BAQEFAASCBKgwggSkAgEAAoIBAQD3Zg0KVn2jff8t
NHk7p8uWEvsaxA59CkGi1v81kyVsnd+yxm23nWIKhGplhy0hK7dnBP3OMB0YCfvo
yXqryQMJb96xMyPkW+n9a1uh3wOibpPzhw/QbVzd5vgMcK9qN2M5oB1iYLEUvlGq
ogQ8r1gYUlt/Of0oIYKIwe9HiQXUTNxnNyW+wrURNkDio4QKMvAEqdG4iEzShAzE
bNLOG4YAdmKxZ+gL0646s5XRTIO7q/3haiF9BszxFul9GiugQ8rdPKxJEvQ9YMMt
cz39wVM4ZvJ8gmUrD5wwucDQXfeiP7bU9meBAQGpXcmYBFpBHI0hTEHYqM0MZ7pW
JVB9eEeFAgMBAAECggEBAK5LBCbjVjJHgu37COoBRcmd57AsrbRj9Gffpf69guEp
vD570zJHu5mDPl32xNGYteXrO0/2z5hu+D1BLJ43yF7upGociE3Kf2fdKbo5nprh
4nPwFDEXyxQ+M0S4YqynBs3DQtBbJIZjqq9W4ztJoPvJkdJpLTQHn6nvTz8LhsLQ
XN9nTWqTNQ3KSiUXPrXkV0dZ2sm2OCjQE99X9rm7araP6Y1FO2irGySPftwGnR+C
/jw1vLzeTCsI9+pZQ2A3JZMwYB5UPQPo/roWJ7tfrT/aT6h+eLpavDUd5W0Wowh/
HqzFQE2bJGE09F8w9mHaQAI+hG/Lr7BbO4sl3n5E3GUCgYEA/TZZc96Jqsom2f5g
iXtl6hX/5DrKVfHp6RzRpQ8aKNokJdTvtd25YiWHUY8h25O28Wdo9QDsKMkuCnlz
EOV3/624iiTGzuVCpB2/LInO4uL5mqYtBVHVDwR41WCOM2RbX5HyB8NqpycIHSO5
gZtb48OSJnGZbHEn1BkoaoywzwcCgYEA+h9Q/Bz/09GHfMNUfsjp4cQ67IX1iHqA
noPqnD8KY1UA2+KR3SBa04zk4KQkilNN5wb1r4XLvFnIWjEEicCQqsw2aEnJwGBI
6Tvd6KWw4xON2SqPlgPH75AOUQwbrsF0Gbee3OktMdOPsG86cTES7XwCOj1syN9d
kxyEMbIbRhMCgYAA8Vbb65QvopkKbrwFRwRWHsbZHq7qKwBn8ceGCcxbIpTH30cV
MkIib2lVkGbb3mzr8Sqe3uYCMN2PBGy9P113AjqRqRlkY84ftkyj6c9vYND1FnFM
d8WHTMj2YmmlH1aHwI9aIAwhmy+YjC2AogdxjaTZp8qecL1pOL7BxsxRuQKBgQCJ
qkjhqnhoNk/zLHNKIP0RhPbFjemZR4uZM5QikVP/Xh7N54NPCOrUuxySQ+XUuIsN
GDiLdgGv1l6+vXH4+6LkTue3OL2xg409yfSWgvO719xf5dwHvmcCBPDMTPTDl7h2
Gyl1/2UfoojYnC+3c0Iuse1r7rj8SmxvduePjq8SPwKBgACswSW/FWGFyqfhXvIv
QWSZF/yiIsywjJgiTsRp92Cr98QDQNC0c8SCQWew3T1r/CHX3EDqjf3djx5qISpi
ESFz5+HMVWL2lMD5KqLxIdHZNe4fbPyW779yMNdyd0rlgOS1kM3WrYdV9tgjc1VI
lweR14IODzhshANib/N8F47e
-----END PRIVATE KEY-----`;

const CERTIFICATE = `-----BEGIN CERTIFICATE-----
MIIDbzCCAlegAwIBAgIUPV0u0uVd+8UHrS6NRz/xVad9oRUwDQYJKoZIhvcNAQEL
BQAwRzELMAkGA1UEBhMCSlAxDjAMBgNVBAgMBUt5b3RvMRIwEAYDVQQKDAlRdWVz
dGV0cmExFDASBgNVBAsMC0RldmVsb3BtZW50MB4XDTI0MDExODA4MDYxMVoXDTI0
MDIxNzA4MDYxMVowRzELMAkGA1UEBhMCSlAxDjAMBgNVBAgMBUt5b3RvMRIwEAYD
VQQKDAlRdWVzdGV0cmExFDASBgNVBAsMC0RldmVsb3BtZW50MIIBIjANBgkqhkiG
9w0BAQEFAAOCAQ8AMIIBCgKCAQEA92YNClZ9o33/LTR5O6fLlhL7GsQOfQpBotb/
NZMlbJ3fssZtt51iCoRqZYctISu3ZwT9zjAdGAn76Ml6q8kDCW/esTMj5Fvp/Wtb
od8Dom6T84cP0G1c3eb4DHCvajdjOaAdYmCxFL5RqqIEPK9YGFJbfzn9KCGCiMHv
R4kF1EzcZzclvsK1ETZA4qOECjLwBKnRuIhM0oQMxGzSzhuGAHZisWfoC9OuOrOV
0UyDu6v94WohfQbM8RbpfRoroEPK3TysSRL0PWDDLXM9/cFTOGbyfIJlKw+cMLnA
0F33oj+21PZngQEBqV3JmARaQRyNIUxB2KjNDGe6ViVQfXhHhQIDAQABo1MwUTAd
BgNVHQ4EFgQU+XQRQgTm3ffYqLngkqr03TFcbvcwHwYDVR0jBBgwFoAU+XQRQgTm
3ffYqLngkqr03TFcbvcwDwYDVR0TAQH/BAUwAwEB/zANBgkqhkiG9w0BAQsFAAOC
AQEAOnZodDZ4tqjkofJbIcuXczFGPta6geFl/my3H2Ubf2PJNEkDxklgml7uMych
vs/lWi0p7YQII52lbMytADKeG/YLOBVQMp5e3WDI3D+630b3T20AwZcXW3KuAYn1
sQuSh7RijcOKDoTMQNUCMjgBbzr5Z4eq0HYl/Uivmkdh5YH0nU2+LbU/G1RDDodh
Q+J3TyL+Ms9ba5V8/7gs7Vaz9uuRBdYpq/MP+Iyb78/yIGOxk9Qj0fXdc+W69XGP
rqpI6o1cfaFHC3zkRdyZA9Tvh3yE3XID9J5xRZRmUuCzUR4YkJQx436E7EzVohq7
lc8AgiU0Y7Qg6Nm8cXQ7LgMfKw==
-----END CERTIFICATE-----`;

/**
 * 設定の準備
 * @param privateKeyId 秘密鍵 ID
 * @param privateKey 秘密鍵
 * @param serviceAccount サービスアカウント
 * @param region リージョンコード
 * @param projectId プロジェクト ID
 * @param model モデル
 * @param maxTokens トークン数の最大値
 * @param message ユーザーのメッセージ
 * @returns {ProcessDataDefinitionView} answerDef
 */
const prepareConfigs = (privateKeyId, privateKey, serviceAccount, region, projectId, model, maxTokens, message) => {
    // 認証設定を作成し、指定
    const jwtAuth = httpClient.createAuthSettingOAuth2JwtBearer('JWT', '', '', privateKeyId, privateKey, serviceAccount, '');
    configs.putObject('conf_Auth', jwtAuth);

    configs.put('conf_Region', region);
    configs.put('conf_ProjectId', projectId);
    configs.put('conf_Model', model);
    configs.put('conf_MaxTokens', maxTokens);
    configs.put('conf_Message1', message);

    // 回答を保存するデータ項目を作成し、指定
    const answerDef = engine.createDataDefinition('回答', 1, 'q_response', 'STRING_TEXTAREA');
    configs.putObject('conf_Answer1', answerDef);
    engine.setData(answerDef, '事前文字列');
    return answerDef;
};

/**
 * 異常系のテスト
 * @param errorMsg
 */
const assertError = (errorMsg) => {
    let failed = false;
    try {
        main();
    } catch (e) {
        failed = true;
        expect(e.message).toEqual(errorMsg);
    }
    if (!failed) {
        fail('No error was thrown.');
    }
};

/**
 * リージョンコードの形式が不正 - ハイフンを含まない
 */
test('Region Code is invalid - no hyphens', () => {
    const privateKeyId = 'key-12345';
    const region = 'invalidregioncode';
    const projectId = 'project-67890';
    const model = 'gemini-pro';
    const serviceAccount = 'service@questetra.com';
    const message = 'Hi. How are you?';
    prepareConfigs(privateKeyId, PRIVATE_KEY, serviceAccount, region, projectId, model, message);

    assertError('Region Code is invalid.');
});

/**
 * リージョンコードの形式が不正 - ハイフンの間の文字列が長すぎる
 */
test('Region Code is invalid - too many characters', () => {
    const privateKeyId = 'key-12345';
    const serviceAccount = 'service@questetra.com';
    const region = 'northamerica-northamericatoooomany1';
    const projectId = 'project-67890';
    const model = 'gemini-pro';
    const maxTokens = '';
    const message = 'Hi. How are you?';
    prepareConfigs(privateKeyId, PRIVATE_KEY, serviceAccount, region, projectId, model, maxTokens, message);

    assertError('Region Code is invalid.');
});

/**
 * トークン数の最大値が正の整数でない - 数字でない文字を含む場合
 */
test('Maximum number of tokens must be a positive integer - includes a non-numeric character', () => {
    const privateKeyId = 'key-12345';
    const serviceAccount = 'service@questetra.com';
    const region = 'asia-northeast1';
    const projectId = 'project-67890';
    const model = 'gemini-pro';
    const maxTokens = '1.1';
    const message = 'Hi. How are you?';
    prepareConfigs(privateKeyId, PRIVATE_KEY, serviceAccount, region, projectId, model, maxTokens, message);

    assertError('Maximum number of tokens must be a positive integer.');
});

/**
 * トークン数の最大値が正の整数でない - ゼロ
 */
test('Maximum number of tokens must be a positive integer - 0', () => {
    const privateKeyId = 'key-12345';
    const serviceAccount = 'service@questetra.com';
    const region = 'asia-northeast1';
    const projectId = 'project-67890';
    const model = 'gemini-pro';
    const maxTokens = '0';
    const message = 'Hi. How are you?';
    prepareConfigs(privateKeyId, PRIVATE_KEY, serviceAccount, region, projectId, model, maxTokens, message);

    assertError('Maximum number of tokens must be a positive integer.');
});

/**
 * メッセージが空
 */
test('Message is empty', () => {
    const privateKeyId = 'key-12345';
    const serviceAccount = 'service@questetra.com';
    const region = 'asia-northeast1';
    const projectId = 'project-67890';
    const model = 'gemini-pro';
    const maxTokens = '';
    const message = '';
    prepareConfigs(privateKeyId, PRIVATE_KEY, serviceAccount, region, projectId, model, maxTokens, message);

    assertError('User Message is empty.');
});

/**
 * 秘密鍵 ID が空
 */
test('Private Key ID is empty', () => {
    const privateKeyId = '';
    const serviceAccount = 'service@questetra.com';
    const region = 'asia-northeast1';
    const projectId = 'project-67890';
    const model = 'gemini-pro';
    const maxTokens = '';
    const message = 'Hi. How are you?';
    prepareConfigs(privateKeyId, PRIVATE_KEY, serviceAccount, region, projectId, model, maxTokens, message);

    assertError('Private Key ID is required.');
});

/**
 * カスタム秘密情報1 に設定されている
 * サービスアカウントが空。
 */
test('Service Account is empty', () => {
    const privateKeyId = 'key-12345';
    const serviceAccount = '';
    const region = 'asia-northeast1';
    const projectId = 'project-67890';
    const model = 'gemini-pro';
    const maxTokens = '';
    const message = 'Hi. How are you?';
    prepareConfigs(privateKeyId, PRIVATE_KEY, serviceAccount, region, projectId, model, maxTokens, message);

    assertError('Service Account must be set to Custom Secret 1.');
});

/**
 * 指定サイズのファイルを作成
 * @param name
 * @param contentType
 * @param size
 * @return qfile
 */
const createQfile = (name, contentType, size) => {
    let text = '';
    if (size >= 4000) {
      text = 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa'.repeat(100); // 40 * 100 = 4000
    }
    while (text.length < size) {
        if (text.length !== 0 && text.length * 2 <= size) {
            text += text;
        } else if (text.length + 1000 <= size) {
            text += 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa'.repeat(25); // 40 * 25 = 1000
        } else {
            text += 'a';
        }
    }
    return engine.createQfile(name, contentType, text);
};

/**
 * 画像・動画を添付
 * @param {Array<Qfile>} images
 */
const attachImages = (images) => {
    const imagesDef = engine.createDataDefinition('添付画像／動画', 2, 'q_images', 'FILE');
    engine.setData(imagesDef, images);
    configs.putObject('conf_Images1', imagesDef);
};

/**
 * 添付ファイルの数が多すぎる
 */
test('Too many attached files', () => {
    const privateKeyId = 'key-12345';
    const serviceAccount = 'service@example.com';
    const region = 'asia-northeast1';
    const projectId = 'project-67890';
    const model = 'gemini-pro-vision';
    const maxTokens = '';
    const message = 'Please describe each image attached.';
    prepareConfigs(privateKeyId, PRIVATE_KEY, serviceAccount, region, projectId, model, maxTokens, message);

    // 添付ファイルを指定
    const images = [];
    for (let i = 0; i < MAX_IMAGE_NUM + 1; i++) {
        images.push(createQfile(`画像${i}.png`, 'image/png', 100));
    }
    attachImages(images);

    assertError(`Too many attached files. The maximum number is ${MAX_IMAGE_NUM}.`);
});

/**
 * 添付ファイルのサイズが大きすぎる
 */
test('Attached file is too large', () => {
    const privateKeyId = 'key-12345';
    const serviceAccount = 'service@example.com';
    const region = 'asia-northeast1';
    const projectId = 'project-67890';
    const model = 'gemini-pro-vision';
    const maxTokens = '';
    const message = 'Please describe each image attached.';
    prepareConfigs(privateKeyId, PRIVATE_KEY, serviceAccount, region, projectId, model, maxTokens, message);

    // 添付ファイルを指定
    const image1 = createQfile('画像1.png', 'image/png', 100);
    const image2 = createQfile('画像2.jpg', 'image/jpeg', MAX_IMAGE_SIZE + 1);
    attachImages([image1, image2]);

    assertError(`Attached file "画像2.jpg" is too large. Each file must be less than ${MAX_IMAGE_SIZE} bytes.`);
});

/**
 * 添付ファイルに画像でも動画でもないファイルを含む
 */
test('Attached file is neither an image nor a video', () => {
    const privateKeyId = 'key-12345';
    const serviceAccount = 'service@example.com';
    const region = 'asia-northeast1';
    const projectId = 'project-67890';
    const model = 'gemini-pro-vision';
    const maxTokens = '';
    const message = 'Please describe each image attached.';
    prepareConfigs(privateKeyId, PRIVATE_KEY, serviceAccount, region, projectId, model, maxTokens, message);

    // 添付ファイルを指定
    const video = createQfile('動画', 'video/mp4', 200);
    const text = createQfile('テキストファイル', 'text/plain', 100);
    attachImages([video, text]);

    assertError('Attached file "テキストファイル" is neither an image nor a video.');
});

/**
 * API リクエストのテスト
 * @param {Object} request
 * @param request.url
 * @param request.method
 * @param request.contentType
 * @param request.body
 * @param {String} serviceAccount
 */
const assertTokenRequest = ({
                                url,
                                method,
                                contentType,
                                body
                            }, serviceAccount) => {
    expect(url).toEqual(URL_TOKEN_REQUEST);
    expect(method).toEqual('POST');
    expect(contentType).startsWith('application/x-www-form-urlencoded');
    const query = `grant_type=${encodeURIComponent('urn:ietf:params:oauth:grant-type:jwt-bearer')}&assertion=`;
    expect(body).startsWith(query);
    const assertion = decodeURIComponent(body.substring(query.length));

    const publicKey = rsa.readKeyFromX509(CERTIFICATE);
    expect(jwt.verify(assertion, publicKey)).toEqual(true);

    const payloadJson = base64.decodeFromUrlSafeString(assertion.split('.')[1]);
    const payload = JSON.parse(payloadJson);
    expect(payload.iss).toEqual(serviceAccount);
    expect(payload.aud).toEqual(URL_TOKEN_REQUEST);
    expect(payload.scope).toEqual(SCOPE);
};

/**
 * API リクエストのテスト
 * @param {Object} request
 * @param request.url
 * @param request.method
 * @param request.contentType
 * @param request.headers
 * @param request.body
 * @param {String} token
 * @param {String} region
 * @param {String} projectId
 * @param {String} model
 * @param {Number} maxTokens
 * @param {String} message
 * @param {Array<Qfile>} images
 */
const assertRequest = ({
                           url,
                           method,
                           contentType,
                           headers,
                           body
                       }, token, region, projectId, model, maxTokens, message, images = []) => {
    expect(url).toEqual(`https://${region}-aiplatform.googleapis.com/v1/projects/${projectId}/locations/${region}/publishers/google/models/${model}:streamGenerateContent`);
    expect(method).toEqual('POST');
    expect(contentType).toEqual('application/json');
    expect(headers.Authorization).toEqual(`Bearer ${token}`);
    const bodyObj = JSON.parse(body);
    expect(bodyObj.contents.parts[0].text).toEqual(message);
    if(maxTokens > 0) {
        expect(bodyObj.generation_config.maxOutputTokens).toEqual(maxTokens);
    }else{
        expect(bodyObj.generation_config.maxOutputTokens).toEqual(undefined);
    }
    images.forEach((image, i) => {
        expect(bodyObj.contents.parts[i + 1].inlineData.mimeType).toEqual(image.getContentType());
        expect(bodyObj.contents.parts[i + 1].inlineData.data).toEqual(base64.encodeToString(fileRepository.readFile(image)));
    });
};

/**
 * API のレスポンスボディを作成
 * @param {String} answers
 * @returns {String} response
 */
const createResponse = (...answers) => {
    const responseObj = answers.map(answer => ({
        "candidates": [{
            "content": {
                "parts": [
                    {
                        "text": answer
                    }
                ]
            },
            "finishReason": 'FINISH_REASON_STOP ',
            "safetyRatings": [],
            "citationMetadata": {
                "citations": []
            }
        }]
    }));
    return JSON.stringify(responseObj);
};

/**
 * API リクエストでエラー
 */
test('Fail to request', () => {
    const privateKeyId = 'key-12345';
    const serviceAccount = 'service@questetra.com';
    const region = 'asia-northeast1';
    const projectId = 'project-67890';
    const model = 'gemini-pro';
    const maxTokens = '';
    const message = 'Hi. How are you?';
    prepareConfigs(privateKeyId, PRIVATE_KEY, serviceAccount, region, projectId, model, maxTokens, message);

    const token = 'token';
    let reqCount = 0;
    httpClient.setRequestHandler((request) => {
        if (reqCount++ === 0) {
            assertTokenRequest(request, serviceAccount);
            return httpClient.createHttpResponse(200, 'application/json', JSON.stringify({
                'access_token': token
            }));
        }
        assertRequest(request, token, region, projectId, model, -1, message);
        return httpClient.createHttpResponse(400, 'application/json', '{}');
    });
    assertError('Failed to invoke model. status: 400');
});

/**
 * 成功
 * gemini-pro
 * 最大トークン数を指定する
 * 添付ファイルなし（データ項目の指定なし）
 */
test('Success - with max tokens, no attached files', () => {
    const privateKeyId = 'key-67890';
    const region = 'asia-northeast1';
    const projectId = 'project-12345';
    const serviceAccount = 'service@example.com';
    const model = 'gemini-pro';
    const maxTokens = '2048';
    const message = 'Hi. How are you?';
    const answerDef = prepareConfigs(privateKeyId, PRIVATE_KEY, serviceAccount, region, projectId, model, maxTokens, message);

    const token = 'token-12345';
    let reqCount = 0;
    httpClient.setRequestHandler((request) => {
        if (reqCount++ === 0) {
            assertTokenRequest(request, serviceAccount);
            return httpClient.createHttpResponse(200, 'application/json', JSON.stringify({
                'access_token': token
            }));
        }
        assertRequest(request, token, region, projectId, model, 2048, message);
        return httpClient.createHttpResponse(200, 'application/json', createResponse('Fine, thanks. ', 'How about you?'));
    });

    expect(main()).toEqual(undefined);
    expect(engine.findData(answerDef)).toEqual('Fine, thanks. How about you?');
});

/**
 * 成功
 * gemini-pro-vision
 * 最大トークン数を指定
 * 添付ファイルなし（データ項目は指定しているが、添付ファイルなし）
 */
test('Success - withmax tokens, empty attached files', () => {
    const privateKeyId = 'key-12345';
    const region = 'asia-southeast1';
    const projectId = 'project-67890';
    const serviceAccount = 'service@questetra.com';
    const model = 'gemini-pro-vision';
    const maxTokens = '1024';
    const message = 'こんにちは。';
    const answerDef = prepareConfigs(privateKeyId, PRIVATE_KEY, serviceAccount, region, projectId, model, maxTokens, message);
    attachImages([]);

    const token = 'token-67890';
    let reqCount = 0;
    httpClient.setRequestHandler((request) => {
        if (reqCount++ === 0) {
            assertTokenRequest(request, serviceAccount);
            return httpClient.createHttpResponse(200, 'application/json', JSON.stringify({
                'access_token': token
            }));
        }
        assertRequest(request, token, region, projectId, model, 1024, message);
        return httpClient.createHttpResponse(200, 'application/json', createResponse('こんにちは。元気ですか？'));
    });

    expect(main()).toEqual(undefined);
    expect(engine.findData(answerDef)).toEqual('こんにちは。元気ですか？');
});

/**
 * 成功
 * gemini-pro-vision
 * 最大トークン数を指定しない
 * 画像ファイルを最大個数添付
 */
test('Success - with default tokens, with max number of attached images', () => {
    const privateKeyId = 'key-12345';
    const region = 'asia-southeast1';
    const projectId = 'project-67890';
    const serviceAccount = 'service@questetra.com';
    const model = 'gemini-pro-vision';
    const maxTokens = '';
    const message = 'Please describe each image attached.';
    const answerDef = prepareConfigs(privateKeyId, PRIVATE_KEY, serviceAccount, region, projectId, model, maxTokens, message);
    
    // 添付ファイルを指定
    const images = [];
    for (let i = 0; i < MAX_IMAGE_NUM; i++) {
        images.push(createQfile(`画像${i}.png`, 'image/png', 100));
    }
    attachImages(images);

    const token = 'token-98765';
    let reqCount = 0;
    httpClient.setRequestHandler((request) => {
        if (reqCount++ === 0) {
            assertTokenRequest(request, serviceAccount);
            return httpClient.createHttpResponse(200, 'application/json', JSON.stringify({
                'access_token': token
            }));
        }
        assertRequest(request, token, region, projectId, model, -1, message, images);
        return httpClient.createHttpResponse(200, 'application/json', createResponse('The 1st image shows a cat. The 2nd image shows a dog.'));
    });

    expect(main()).toEqual(undefined);
    expect(engine.findData(answerDef)).toEqual('The 1st image shows a cat. The 2nd image shows a dog.');
});

/**
 * 成功
 * gemini-pro-vision
 * 最大トークン数を指定しない
 * 動画ファイルを 1 つ添付
 */
test('Success - with default tokens, with an attached video', () => {
    const privateKeyId = 'key-12345';
    const region = 'asia-southeast1';
    const projectId = 'project-67890';
    const serviceAccount = 'service@questetra.com';
    const model = 'gemini-pro-vision';
    const maxTokens = '';
    const message = 'Please describe the video attached.';
    const answerDef = prepareConfigs(privateKeyId, PRIVATE_KEY, serviceAccount, region, projectId, model, maxTokens, message);
    
    // 添付ファイルを指定
    const video = createQfile('動画.mp4', 'video/mp4', MAX_IMAGE_SIZE);
    attachImages([video]);

    const token = 'token-98765';
    let reqCount = 0;
    httpClient.setRequestHandler((request) => {
        if (reqCount++ === 0) {
            assertTokenRequest(request, serviceAccount);
            return httpClient.createHttpResponse(200, 'application/json', JSON.stringify({
                'access_token': token
            }));
        }
        assertRequest(request, token, region, projectId, model, -1, message, [video]);
        return httpClient.createHttpResponse(200, 'application/json', createResponse('The video shows a sleeping cat.'));
    });

    expect(main()).toEqual(undefined);
    expect(engine.findData(answerDef)).toEqual('The video shows a sleeping cat.');
});

]]></test>
</service-task-definition>